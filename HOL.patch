diff -urNx '*~' ./Enum.thy /cygdrive/c/Isabelle2022/src/HOL/Enum.thy
--- ./Enum.thy	2023-05-30 11:50:42.024180400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Enum.thy	2023-06-01 11:16:35.187000700 +0900
@@ -929,15 +929,47 @@
 definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
 definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
 definition "sgn = (\<lambda>x :: finite_3. x)"
+
+lemmas [simp] = times_finite_3_def plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+  inverse_finite_3_def divide_finite_3_def sgn_finite_3_def abs_finite_3_def modulo_finite_3_def
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
-        times_finite_3_def
-        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
-        abs_finite_3_def sgn_finite_3_def
-        less_finite_3_def
-        split: finite_3.splits\<close>)
+    apply standard
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  done
+
+lemmas [simp del] = times_finite_3_def plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+  inverse_finite_3_def divide_finite_3_def sgn_finite_3_def abs_finite_3_def modulo_finite_3_def
+
 end
 
 lemma two_finite_3 [simp]:
@@ -953,17 +985,30 @@
 definition [simp]: "unit_factor = (id :: finite_3 \<Rightarrow> _)"
 definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | _ \<Rightarrow> 1)"
 definition [simp]: "division_segment (x :: finite_3) = 1"
+
+lemmas [simp] = divide_finite_3_def times_finite_3_def
+      dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
 instance
-proof
-  fix x :: finite_3
-  assume "x \<noteq> 0"
-  then show "is_unit (unit_factor x)"
-    by (cases x) (simp_all add: dvd_finite_3_unfold)
-qed
-  (subproofs
-    \<open>auto simp add: divide_finite_3_def times_finite_3_def
+   apply intro_classes
+  subgoal by simp
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  done
+
+lemmas [simp del] = divide_finite_3_def times_finite_3_def
       dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
-      split: finite_3.splits\<close>)
+
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3
@@ -1034,11 +1079,33 @@
   | (a\<^sub>3, _) \<Rightarrow> a\<^sub>3 | (_, a\<^sub>3) \<Rightarrow> a\<^sub>3
   | _ \<Rightarrow> a\<^sub>1)"
 
+lemmas [simp] = less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
+        inf_finite_4_def sup_finite_4_def
+
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
-        inf_finite_4_def sup_finite_4_def split: finite_4.splits\<close>)
+  apply intro_classes
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  done
+
+lemmas [simp del] = less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
+        inf_finite_4_def sup_finite_4_def
+
 end
 
 instance finite_4 :: complete_lattice ..
@@ -1048,11 +1115,14 @@
 instantiation finite_4 :: complete_boolean_algebra begin
 definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>4 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2 | a\<^sub>4 \<Rightarrow> a\<^sub>1)"
 definition "x - y = x \<sqinter> - (y :: finite_4)"
+lemmas [simp] =  inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def 
-        split: finite_4.splits\<close>)
+  apply intro_classes
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  done
+lemmas [simp del] =  inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3 a\<^sub>4
@@ -1138,11 +1208,30 @@
    | (a\<^sub>4, _) \<Rightarrow> a\<^sub>4 | (_, a\<^sub>4) \<Rightarrow> a\<^sub>4
    | _ \<Rightarrow> a\<^sub>1)"
 
+lemmas [simp] = less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
+        Inf_finite_5_def Sup_finite_5_def
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
-        Inf_finite_5_def Sup_finite_5_def split: finite_5.splits if_split_asm\<close>)
+  apply intro_classes
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  done
+lemmas [simp del] = less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
+        Inf_finite_5_def Sup_finite_5_def
+
 end
 
 
diff -urNx '*~' ./Euclidean_Division.thy /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy
--- ./Euclidean_Division.thy	2023-05-30 11:50:42.373685700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Euclidean_Division.thy	2023-05-31 15:33:10.919027800 +0900
@@ -2795,8 +2795,8 @@
   finally have *: \<open>\<bar>k\<bar> div \<bar>l\<bar> \<noteq> 0 \<longleftrightarrow> \<bar>l\<bar> \<le> \<bar>k\<bar>\<close> .
   show ?thesis
     using \<open>0 \<le> \<bar>k\<bar> div \<bar>l\<bar>\<close> False
-  by (auto simp add: div_eq_div_abs [of k l] div_eq_sgn_abs [of k l]
-    sgn_mult sgn_1_pos sgn_1_neg sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest: sgn_not_eq_imp)
+  by (auto simp add: div_eq_div_abs [of k l] (* redundant and looping! div_eq_sgn_abs [of k l] *)
+    sgn_mult sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest!: sgn_not_eq_imp)
 qed
 
 
diff -urNx '*~' ./Factorial.thy /cygdrive/c/Isabelle2022/src/HOL/Factorial.thy
--- ./Factorial.thy	2023-05-30 11:49:53.645647300 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Factorial.thy	2023-05-31 14:26:38.861397700 +0900
@@ -28,7 +28,7 @@
   have "prod Suc {0..<n} = \<Prod>{1..n}"
     by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
   then have "prod Suc {0..<n} = prod ((-) (n + 1)) {1..n}"
-    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by presburger
+    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by auto
   then show ?thesis
     unfolding fact_prod_Suc by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
 qed
diff -urNx '*~' ./Groups_List.thy /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy
--- ./Groups_List.thy	2023-05-30 11:49:53.253421400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Groups_List.thy	2023-05-31 15:58:09.698128300 +0900
@@ -3,7 +3,7 @@
 section \<open>Sum and product over lists\<close>
 
 theory Groups_List
-imports List
+imports List Divides
 begin
 
 locale monoid_list = monoid
diff -urNx '*~' ./List.thy /cygdrive/c/Isabelle2022/src/HOL/List.thy
--- ./List.thy	2023-05-30 11:50:42.721423600 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/List.thy	2023-06-01 13:37:53.298674500 +0900
@@ -5,7 +5,7 @@
 section \<open>The datatype of finite lists\<close>
 
 theory List
-imports Sledgehammer Lifting_Set
+imports Lifting_Set Set_Interval Numeral_Simprocs
 begin
 
 datatype (set: 'a) list =
@@ -962,13 +962,13 @@
 by (induct xs) auto
 
 lemma hd_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> hd (xs @ ys) = hd xs"
-by (simp add: hd_append split: list.split)
+by (simp add: hd_append)
 
 lemma tl_append: "tl (xs @ ys) = (case xs of [] \<Rightarrow> tl ys | z#zs \<Rightarrow> zs @ ys)"
-by (simp split: list.split)
+by (cases xs; simp)
 
 lemma tl_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> tl (xs @ ys) = tl xs @ ys"
-by (simp add: tl_append split: list.split)
+by (cases xs;simp add: tl_append)
 
 lemma tl_append_if: "tl (xs @ ys) = (if xs = [] then tl ys else tl xs @ ys)"
 by (simp)
@@ -1591,7 +1591,7 @@
   proof (cases)
     assume "p x"
     hence eq: "?S' = insert 0 (Suc ` ?S)"
-      by(auto simp: image_def split:nat.split dest:gr0_implies_Suc)
+      by (auto simp: image_def dest:gr0_implies_Suc)
     have "length (filter p (x # xs)) = Suc(card ?S)"
       using Cons \<open>p x\<close> by simp
     also have "\<dots> = Suc(card(Suc ` ?S))" using fin
@@ -2440,7 +2440,7 @@
   by (induct xs) (auto split: if_split_asm)
 
 lemma set_takeWhileD: "x \<in> set (takeWhile P xs) \<Longrightarrow> x \<in> set xs \<and> P x"
-  by (induct xs) (auto split: if_split_asm)
+  by (induct xs) auto 
 
 lemma takeWhile_eq_all_conv[simp]:
   "(takeWhile P xs = xs) = (\<forall>x \<in> set xs. P x)"
@@ -2596,7 +2596,7 @@
 
 lemma zip_Cons1:
   "zip (x#xs) ys = (case ys of [] \<Rightarrow> [] | y#ys \<Rightarrow> (x,y)#zip xs ys)"
-  by(auto split:list.split)
+  by (cases xs; cases ys; simp)
 
 lemma length_zip [simp]:
   "length (zip xs ys) = min (length xs) (length ys)"
@@ -4462,9 +4462,10 @@
   distinct (removeAll [] xs) \<and>
   (\<forall>ys. ys \<in> set xs \<longrightarrow> distinct ys) \<and>
   (\<forall>ys zs. ys \<in> set xs \<and> zs \<in> set xs \<and> ys \<noteq> zs \<longrightarrow> set ys \<inter> set zs = {})"
-apply (induct xs)
- apply(simp_all, safe, auto)
-by (metis Int_iff UN_I empty_iff equals0I set_empty)
+proof(induct xs)
+  case (Cons a xs)
+  show ?case by (auto simp: Cons Ball_def disjnt_def[symmetric] disjnt_sym)
+qed simp
 
 
 subsubsection \<open>\<^const>\<open>replicate\<close>\<close>
@@ -5050,7 +5051,10 @@
   "z # zs \<in> shuffles xs ys \<longleftrightarrow>
     (xs \<noteq> [] \<and> hd xs = z \<and> zs \<in> shuffles (tl xs) ys \<or>
      ys \<noteq> [] \<and> hd ys = z \<and> zs \<in> shuffles xs (tl ys))"
-  by (induct xs ys rule: shuffles.induct) auto
+proof(induct xs ys rule: shuffles.induct)
+  case (3 x xs y ys)
+  show ?case by (auto simp: 3)
+qed auto
 
 lemma splice_in_shuffles [simp, intro]: "splice xs ys \<in> shuffles xs ys"
   by (induction xs ys rule: splice.induct) (simp_all add: Cons_in_shuffles_iff shuffles_commutes)
@@ -5197,13 +5201,12 @@
   (is "max _ ?foldB = Suc (max _ ?foldA)")
 proof (cases "(filter (\<lambda>ys. ys \<noteq> []) xss) = []")
   case True
-  hence "foldr (\<lambda>xs. max (length xs)) xss 0 = 0"
+  then show ?thesis 
   proof (induct xss)
-    case (Cons x xs)
-    then have "x = []" by (cases x) auto
-    with Cons show ?case by auto
+    case (Cons a xsss)
+    then show ?case 
+      by (cases a; simp add: filter_def)
   qed simp
-  thus ?thesis using True by simp
 next
   case False
 
@@ -6363,7 +6366,7 @@
 
 lemma sorted_list_of_set_lessThan_Suc [simp]:
   "sorted_list_of_set {..<Suc k} = sorted_list_of_set {..<k} @ [k]"
-  using le0 lessThan_atLeast0 sorted_list_of_set_range upt_Suc_append by presburger
+  using lessThan_atLeast0 by auto
 
 lemma sorted_list_of_set_atMost_Suc [simp]:
   "sorted_list_of_set {..Suc k} = sorted_list_of_set {..k} @ [Suc k]"
@@ -6835,7 +6838,7 @@
     by blast
   hence "((u@v)!i, (w@z)!i) \<in> r"
     unfolding nth_append using less_le_trans[OF \<open>i < length w\<close> assms(2)] \<open>(u!i,w!i) \<in> r\<close>
-    by presburger
+    by auto
   moreover have "i < min (length (u@v)) (length (w@z))"
     using assms(2) \<open>i < length w\<close> by simp
   moreover have "take i (u@v) = take i (w@z)"
diff -urNx '*~' ./MacLaurin.thy /cygdrive/c/Isabelle2022/src/HOL/MacLaurin.thy
--- ./MacLaurin.thy	2023-05-30 11:50:42.798563100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/MacLaurin.thy	2023-06-01 13:42:54.647162000 +0900
@@ -22,7 +22,7 @@
 
 lemma eq_diff_eq': "x = y - z \<longleftrightarrow> y = x + z"
   for x y z :: real
-  by arith
+  by (auto elim: iffE)
 
 lemma fact_diff_Suc: "n < Suc m \<Longrightarrow> fact (Suc m - n) = (Suc m - n) * fact (m - n)"
   by (subst fact_reduce) auto
@@ -343,25 +343,37 @@
 lemma sin_expansion_lemma: "sin (x + real (Suc m) * pi / 2) = cos (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add add_divide_distrib distrib_right)
 
+lemma sin_coeff_lemma: "sin_coeff m * x ^ m  = sin (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "even m")
+  case t: True
+    then show ?thesis by (simp add: sin_coeff_def sin_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: sin_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_sin_expansion2:
   "\<exists>t. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
 proof (cases "n = 0 \<or> x = 0")
+  case True
+  then show ?thesis by auto
+next
   case False
   let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
-  have "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
-      (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
+  have tex: "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
+    (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
   proof (rule Maclaurin_all_lt)
     show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
-           sin (x + 1/2 * real (Suc m) * pi)) (at x)"
+       sin (x + 1/2 * real (Suc m) * pi)) (at x)"
       by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
   qed (use False in auto)
-  then show ?thesis
+  from tex show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
-qed auto
+    by (simp add: sin_coeff_lemma)
+qed
 
 lemma Maclaurin_sin_expansion:
   "\<exists>t. sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -385,8 +397,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 lemma Maclaurin_sin_expansion4:
@@ -406,8 +417,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 
@@ -419,6 +429,16 @@
 lemma cos_expansion_lemma: "cos (x + real (Suc m) * pi / 2) = - sin (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add distrib_right add_divide_distrib)
 
+lemma cos_coeff_lemma: "cos_coeff m * x ^ m  = cos (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "odd m")
+  case t: True
+    then show ?thesis by (simp add: cos_coeff_def cos_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: cos_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_cos_expansion:
   "\<exists>t::real. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     cos x = (\<Sum>m<n. cos_coeff m * x ^ m) + (cos(t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -436,8 +456,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE simp del: of_nat_Suc)
-    done
+    by (simp add: cos_coeff_lemma)
 qed auto
 
 lemma Maclaurin_cos_expansion2:
@@ -456,8 +475,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 lemma Maclaurin_minus_cos_expansion:
@@ -476,8 +494,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 
@@ -537,7 +554,7 @@
   shows "\<exists>t::real. c < t \<and> t < b \<and>
     f b = (\<Sum>m<n. (diff m c / fact m) * (b - c)^m) + (diff n t / fact n) * (b - c)^n"
 proof -
-  from INTERV have "0 < b - c" by arith
+  from INTERV have "0 < b - c" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -573,7 +590,7 @@
   shows "\<exists>t. a < t \<and> t < c \<and>
     f a = (\<Sum>m<n. (diff m c / fact m) * (a - c)^m) + (diff n t / fact n) * (a - c)^n"
 proof -
-  from INTERV have "a-c < 0" by arith
+  from INTERV have "a-c < 0" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -627,9 +644,9 @@
   moreover have "\<forall>m t. m < n \<and> a \<le> t \<and> t \<le> x \<longrightarrow> DERIV (diff m) t :> diff (Suc m) t"
     using DERIV and INTERV by fastforce
   moreover from INTERV have "a \<le> c"
-    by arith
+    by simp
   moreover from False and INTERV have "c < x"
-    by arith
+    by simp
   ultimately have "\<exists>t>c. t < x \<and> f x =
     (\<Sum>m<n. diff m c / (fact m) * (x - c) ^ m) + diff n t / (fact n) * (x - c) ^ n"
     by (rule Taylor_up)
diff -urNx '*~' ./Main.thy /cygdrive/c/Isabelle2022/src/HOL/Main.thy
--- ./Main.thy	2023-05-30 11:49:55.729754800 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Main.thy	2023-05-31 14:26:38.879025000 +0900
@@ -8,10 +8,10 @@
 theory Main
   imports
     Predicate_Compile
-    Quickcheck_Narrowing
+    (*Quickcheck_Narrowing*)
     Mirabelle
     Extraction
-    Nunchaku
+    (*Nunchaku*)
     BNF_Greatest_Fixpoint
     Filter
     Conditionally_Complete_Lattices
diff -urNx '*~' ./Nitpick.thy /cygdrive/c/Isabelle2022/src/HOL/Nitpick.thy
--- ./Nitpick.thy	2023-05-30 11:49:54.739036200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Nitpick.thy	2023-05-31 14:26:38.879025000 +0900
@@ -8,7 +8,7 @@
 section \<open>Nitpick: Yet Another Counterexample Generator for Isabelle/HOL\<close>
 
 theory Nitpick
-imports Record GCD
+imports Record GCD Sledgehammer
 keywords
   "nitpick" :: diag and
   "nitpick_params" :: thy_decl
diff -urNx '*~' ./Predicate_Compile.thy /cygdrive/c/Isabelle2022/src/HOL/Predicate_Compile.thy
--- ./Predicate_Compile.thy	2023-05-30 11:49:55.926685800 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Predicate_Compile.thy	2023-05-31 14:26:38.879025000 +0900
@@ -1,11 +1,7 @@
-(*  Title:      HOL/Predicate_Compile.thy
-    Author:     Stefan Berghofer, Lukas Bulwahn, Florian Haftmann, TU Muenchen
-*)
-
 section \<open>A compiler for predicates defined by introduction rules\<close>
 
 theory Predicate_Compile
-imports Random_Sequence Quickcheck_Exhaustive
+imports Random_Sequence Random_Prep (*Quickcheck_Exhaustive*)
 keywords
   "code_pred" :: thy_goal and
   "values" :: diag
diff -urNx '*~' ./Quickcheck_Exhaustive.thy /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Exhaustive.thy
--- ./Quickcheck_Exhaustive.thy	2023-05-30 11:49:56.585222900 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Exhaustive.thy	2023-05-31 14:26:38.894298600 +0900
@@ -15,14 +15,14 @@
   where [code_unfold]: "x orelse y = (case x of Some x' \<Rightarrow> Some x' | None \<Rightarrow> y)"
 
 
-subsection \<open>Exhaustive generator type classes\<close>
+(*subsection \<open>Exhaustive generator type classes\<close>
 
 class exhaustive = term_of +
   fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
 
 class full_exhaustive = term_of +
   fixes full_exhaustive ::
-    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"*)
 
 instantiation natural :: full_exhaustive
 begin
@@ -226,7 +226,7 @@
      else
       f valterm_emptyset orelse
       full_exhaustive_set
-        (\<lambda>A. f A orelse Quickcheck_Exhaustive.full_exhaustive
+        (\<lambda>A. f A orelse Random_Prep.full_exhaustive
           (\<lambda>x. if fst x \<in> fst A then None else f (valtermify_insert x A)) (i - 1)) (i - 1))"
 
 instance ..
@@ -649,7 +649,7 @@
     (Quickcheck) "(((_); NONE) handle Exhaustive'_Generators.Counterexample ts \<Rightarrow> SOME ts)"
 
 
-subsection \<open>Continuation passing style functions as plus monad\<close>
+(*subsection \<open>Continuation passing style functions as plus monad\<close>
 
 type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
 
@@ -731,7 +731,7 @@
 
 definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
   where "pos_bound_cps_not n =
-    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"*)
 
 
 subsection \<open>Defining generators for any first-order data type\<close>
@@ -766,13 +766,13 @@
   check_all enum_term_of
   orelse unknown mk_map_term check_all_n_lists check_all_subsets
 
-hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+(*hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
 
 hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
   pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
   pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
   neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
   neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
-  Unknown Known Unknown_value Value No_value
+  Unknown Known Unknown_value Value No_value*)
 
 end
diff -urNx '*~' ./Quickcheck_Random.thy /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Random.thy
--- ./Quickcheck_Random.thy	2023-05-30 11:49:56.406913000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Quickcheck_Random.thy	2023-05-31 14:26:38.896504500 +0900
@@ -5,7 +5,7 @@
 section \<open>A simple counterexample generator performing random testing\<close>
 
 theory Quickcheck_Random
-imports Random Code_Evaluation Enum
+  imports Random_Prep
 begin
 
 setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>
@@ -19,7 +19,7 @@
 
 code_reserved Quickcheck Match
 
-subsection \<open>The \<open>random\<close> class\<close>
+(*subsection \<open>The \<open>random\<close> class\<close>
 
 class random = typerep +
   fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
@@ -182,7 +182,7 @@
 
 instance ..
 
-end
+end*)
 
 text \<open>Towards type copies and datatypes\<close>
 
@@ -213,7 +213,7 @@
 
 end
 
-instantiation set :: (random) random
+instantiation set :: (Random_Prep.random) Random_Prep.random
 begin
 
 context
@@ -227,12 +227,13 @@
     collapse (Random.select_weight
       [(1, Pair valterm_emptyset),
        (Code_Numeral.Suc i,
-        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+        Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
 
 lemma [code]:
   "random_aux_set i j =
     collapse (Random.select_weight [(1, Pair valterm_emptyset),
-      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+      (i, Random_Prep.random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
 proof (induct i rule: natural.induct)
   case zero
   show ?case by (subst select_weight_drop_zero [symmetric])
@@ -259,6 +260,10 @@
 
 subsection \<open>Deriving random generators for datatypes\<close>
 
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
 ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
 ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
 
@@ -266,15 +271,15 @@
 subsection \<open>Code setup\<close>
 
 code_printing
-  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  constant Random_Prep.random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
   \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
   for this reason we use a distinguished target \<open>Quickcheck\<close>
   not spoiling the regular trusted code generation\<close>
 
 code_reserved Quickcheck Random_Generators
 
-hide_const (open) catch_match random collapse beyond random_fun_aux random_fun_lift
+hide_const (open) catch_match random collapse beyond (*random_fun_aux random_fun_lift*)
 
-hide_fact (open) collapse_def beyond_def random_fun_lift_def
+hide_fact (open) collapse_def beyond_def (*random_fun_lift_def*)
 
 end
diff -urNx '*~' ./Random_Pred.thy /cygdrive/c/Isabelle2022/src/HOL/Random_Pred.thy
--- ./Random_Pred.thy	2023-05-30 11:49:57.822544100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Random_Pred.thy	2023-05-31 14:26:38.898682900 +0900
@@ -4,13 +4,13 @@
 section \<open>The Random-Predicate Monad\<close>
 
 theory Random_Pred
-imports Quickcheck_Random
+imports Random_Prep
 begin
 
 fun iter' :: "'a itself \<Rightarrow> natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
 where
   "iter' T nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter' T (nrandom - 1) sz seed')))"
 
 definition iter :: "natural \<Rightarrow> natural \<Rightarrow> Random.seed \<Rightarrow> ('a::random) Predicate.pred"
@@ -19,7 +19,7 @@
 
 lemma [code]:
   "iter nrandom sz seed = (if nrandom = 0 then bot_class.bot else
-     let ((x, _), seed') = Quickcheck_Random.random sz seed
+     let ((x, _), seed') = Random_Prep.random sz seed
    in Predicate.Seq (%u. Predicate.Insert x (iter (nrandom - 1) sz seed')))"
    unfolding iter_def iter'.simps [of _ nrandom] ..
 
diff -urNx '*~' ./Random_Prep.thy /cygdrive/c/Isabelle2022/src/HOL/Random_Prep.thy
--- ./Random_Prep.thy	1970-01-01 09:00:00.000000000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Random_Prep.thy	2023-05-31 14:31:21.495846600 +0900
@@ -0,0 +1,386 @@
+(*  Title:      HOL/Quickcheck_Random.thy
+    Author:     Florian Haftmann & Lukas Bulwahn, TU Muenchen
+*)
+
+section \<open>A simple counterexample generator performing random testing\<close>
+
+theory Random_Prep
+imports Random Code_Evaluation Enum
+begin
+
+(*setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>*)
+
+(*subsection \<open>Catching Match exceptions\<close>
+
+axiomatization catch_match :: "'a => 'a => 'a"
+
+code_printing
+  constant catch_match \<rightharpoonup> (Quickcheck) "((_) handle Match => _)"
+
+code_reserved Quickcheck Match*)
+
+subsection \<open>The \<open>random\<close> class\<close>
+
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
+subsection \<open>Fundamental and numeric types\<close>
+
+instantiation bool :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range 2 \<circ>\<rightarrow>
+    (\<lambda>k. Pair (if k = 0 then Code_Evaluation.valtermify False else Code_Evaluation.valtermify True))"
+
+instance ..
+
+end
+
+end
+
+instantiation itself :: (typerep) random
+begin
+
+definition
+  random_itself :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a itself \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where "random_itself _ = Pair (Code_Evaluation.valtermify TYPE('a))"
+
+instance ..
+
+end
+
+instantiation char :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random _ = Random.select (Enum.enum :: char list) \<circ>\<rightarrow> (\<lambda>c. Pair (c, \<lambda>u. Code_Evaluation.term_of c))"
+
+instance ..
+
+end
+
+end
+
+instantiation String.literal :: random
+begin
+
+definition
+  "random _ = Pair (STR '''', \<lambda>u. Code_Evaluation.term_of (STR ''''))"
+
+instance ..
+
+end
+
+instantiation nat :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_nat :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (nat \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_nat i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let n = nat_of_natural k
+     in (n, \<lambda>_. Code_Evaluation.term_of n)))"
+
+instance ..
+
+end
+
+end
+
+instantiation int :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then int (nat_of_natural (k - i)) else - (int (nat_of_natural (i - k))))
+     in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+instantiation natural :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_natural :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (natural \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_natural i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>n. Pair (n, \<lambda>_. Code_Evaluation.term_of n))"
+
+instance ..
+
+end
+
+end
+
+instantiation integer :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_integer :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (integer \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_integer i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then integer_of_natural (k - i) else - (integer_of_natural (i - k)))
+      in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+
+subsection \<open>Complex generators\<close>
+
+text \<open>Towards \<^typ>\<open>'a \<Rightarrow> 'b\<close>\<close>
+
+axiomatization random_fun_aux :: "typerep \<Rightarrow> typerep \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a \<Rightarrow> term)
+  \<Rightarrow> (Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> (Random.seed \<Rightarrow> Random.seed \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+definition random_fun_lift :: "(Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a::term_of \<Rightarrow> 'b::typerep) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where
+  "random_fun_lift f =
+    random_fun_aux TYPEREP('a) TYPEREP('b) (=) Code_Evaluation.term_of f Random.split_seed"
+
+instantiation "fun" :: ("{equal, term_of}", random) random
+begin
+
+definition
+  random_fun :: "natural \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+  where "random i = random_fun_lift (random i)"
+
+instance ..
+
+end
+
+(*text \<open>Towards type copies and datatypes\<close>
+
+context
+  includes state_combinator_syntax
+begin
+
+definition collapse :: "('a \<Rightarrow> ('a \<Rightarrow> 'b \<times> 'a) \<times> 'a) \<Rightarrow> 'a \<Rightarrow> 'b \<times> 'a"
+  where "collapse f = (f \<circ>\<rightarrow> id)"
+
+end
+
+definition beyond :: "natural \<Rightarrow> natural \<Rightarrow> natural"
+  where "beyond k l = (if l > k then l else 0)"
+
+lemma beyond_zero: "beyond k 0 = 0"
+  by (simp add: beyond_def)
+
+context
+  includes term_syntax
+begin
+
+definition [code_unfold]:
+  "valterm_emptyset = Code_Evaluation.valtermify ({} :: ('a :: typerep) set)"
+
+definition [code_unfold]:
+  "valtermify_insert x s = Code_Evaluation.valtermify insert {\<cdot>} (x :: ('a :: typerep * _)) {\<cdot>} s"
+
+end
+
+instantiation set :: (random) random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+
+fun random_aux_set
+where
+  "random_aux_set 0 j = collapse (Random.select_weight [(1, Pair valterm_emptyset)])"
+| "random_aux_set (Code_Numeral.Suc i) j =
+    collapse (Random.select_weight
+      [(1, Pair valterm_emptyset),
+       (Code_Numeral.Suc i,
+        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
+
+lemma [code]:
+  "random_aux_set i j =
+    collapse (Random.select_weight [(1, Pair valterm_emptyset),
+      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+proof (induct i rule: natural.induct)
+  case zero
+  show ?case by (subst select_weight_drop_zero [symmetric])
+    (simp add: random_aux_set.simps [simplified] less_natural_def)
+next
+  case (Suc i)
+  show ?case by (simp only: random_aux_set.simps(2) [of "i"] Suc_natural_minus_one)
+qed
+
+definition "random_set i = random_aux_set i i"
+
+instance ..
+
+end
+
+end
+
+lemma random_aux_rec:
+  fixes random_aux :: "natural \<Rightarrow> 'a"
+  assumes "random_aux 0 = rhs 0"
+    and "\<And>k. random_aux (Code_Numeral.Suc k) = rhs (Code_Numeral.Suc k)"
+  shows "random_aux k = rhs k"
+  using assms by (rule natural.induct)*)
+
+(*subsection \<open>Deriving random generators for datatypes\<close>
+
+ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
+ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
+
+
+subsection \<open>Code setup\<close>
+
+code_printing
+  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
+  for this reason we use a distinguished target \<open>Quickcheck\<close>
+  not spoiling the regular trusted code generation\<close>
+
+code_reserved Quickcheck Random_Generators*)
+
+hide_const (open) (*catch_match*) random (*collapse beyond*) random_fun_aux random_fun_lift
+
+hide_fact (open) (*collapse_def beyond_def*) random_fun_lift_def
+
+
+
+subsection \<open>Continuation passing style functions as plus monad\<close>
+
+type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
+
+definition cps_empty :: "'a cps"
+  where "cps_empty = (\<lambda>cont. None)"
+
+definition cps_single :: "'a \<Rightarrow> 'a cps"
+  where "cps_single v = (\<lambda>cont. cont v)"
+
+definition cps_bind :: "'a cps \<Rightarrow> ('a \<Rightarrow> 'b cps) \<Rightarrow> 'b cps"
+  where "cps_bind m f = (\<lambda>cont. m (\<lambda>a. (f a) cont))"
+
+definition cps_plus :: "'a cps \<Rightarrow> 'a cps \<Rightarrow> 'a cps"
+  where "cps_plus a b = (\<lambda>c. case a c of None \<Rightarrow> b c | Some x \<Rightarrow> Some x)"
+
+definition cps_if :: "bool \<Rightarrow> unit cps"
+  where "cps_if b = (if b then cps_single () else cps_empty)"
+
+definition cps_not :: "unit cps \<Rightarrow> unit cps"
+  where "cps_not n = (\<lambda>c. case n (\<lambda>u. Some []) of None \<Rightarrow> c () | Some _ \<Rightarrow> None)"
+
+type_synonym 'a pos_bound_cps =
+  "('a \<Rightarrow> (bool * term list) option) \<Rightarrow> natural \<Rightarrow> (bool * term list) option"
+
+definition pos_bound_cps_empty :: "'a pos_bound_cps"
+  where "pos_bound_cps_empty = (\<lambda>cont i. None)"
+
+definition pos_bound_cps_single :: "'a \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_single v = (\<lambda>cont i. cont v)"
+
+definition pos_bound_cps_bind :: "'a pos_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b pos_bound_cps) \<Rightarrow> 'b pos_bound_cps"
+  where "pos_bound_cps_bind m f = (\<lambda>cont i. if i = 0 then None else (m (\<lambda>a. (f a) cont i) (i - 1)))"
+
+definition pos_bound_cps_plus :: "'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_plus a b = (\<lambda>c i. case a c i of None \<Rightarrow> b c i | Some x \<Rightarrow> Some x)"
+
+definition pos_bound_cps_if :: "bool \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_if b = (if b then pos_bound_cps_single () else pos_bound_cps_empty)"
+
+datatype (plugins only: code extraction) (dead 'a) unknown =
+  Unknown | Known 'a
+
+datatype (plugins only: code extraction) (dead 'a) three_valued =
+  Unknown_value | Value 'a | No_value
+
+type_synonym 'a neg_bound_cps =
+  "('a unknown \<Rightarrow> term list three_valued) \<Rightarrow> natural \<Rightarrow> term list three_valued"
+
+definition neg_bound_cps_empty :: "'a neg_bound_cps"
+  where "neg_bound_cps_empty = (\<lambda>cont i. No_value)"
+
+definition neg_bound_cps_single :: "'a \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_single v = (\<lambda>cont i. cont (Known v))"
+
+definition neg_bound_cps_bind :: "'a neg_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b neg_bound_cps) \<Rightarrow> 'b neg_bound_cps"
+  where "neg_bound_cps_bind m f =
+    (\<lambda>cont i.
+      if i = 0 then cont Unknown
+      else m (\<lambda>a. case a of Unknown \<Rightarrow> cont Unknown | Known a' \<Rightarrow> f a' cont i) (i - 1))"
+
+definition neg_bound_cps_plus :: "'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_plus a b =
+    (\<lambda>c i.
+      case a c i of
+        No_value \<Rightarrow> b c i
+      | Value x \<Rightarrow> Value x
+      | Unknown_value \<Rightarrow>
+          (case b c i of
+            No_value \<Rightarrow> Unknown_value
+          | Value x \<Rightarrow> Value x
+          | Unknown_value \<Rightarrow> Unknown_value))"
+
+definition neg_bound_cps_if :: "bool \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_if b = (if b then neg_bound_cps_single () else neg_bound_cps_empty)"
+
+definition neg_bound_cps_not :: "unit pos_bound_cps \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Some (True, [])) i of None \<Rightarrow> c (Known ()) | Some _ \<Rightarrow> No_value)"
+
+definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+
+hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+
+hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
+  pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
+  pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
+  neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
+  neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
+  Unknown Known Unknown_value Value No_value
+
+class exhaustive = term_of +
+  fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+class full_exhaustive = term_of +
+  fixes full_exhaustive ::
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+
+
+end
diff -urNx '*~' ./Rat.thy /cygdrive/c/Isabelle2022/src/HOL/Rat.thy
--- ./Rat.thy	2023-05-30 11:50:42.466861600 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Rat.thy	2023-05-31 14:26:38.902063300 +0900
@@ -1010,7 +1010,7 @@
   by (cases p) (simp add: quotient_of_Fract of_rat_rat)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1129,7 +1129,7 @@
   inverse_rat_inst.inverse_rat
   one_rat_inst.one_rat ord_rat_inst.less_rat
   ord_rat_inst.less_eq_rat plus_rat_inst.plus_rat times_rat_inst.times_rat
-  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat
+  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat*)
 
 
 subsection \<open>Float syntax\<close>
diff -urNx '*~' ./Real.thy /cygdrive/c/Isabelle2022/src/HOL/Real.thy
--- ./Real.thy	2023-05-30 11:50:42.529129200 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Real.thy	2023-05-31 14:26:38.904474700 +0900
@@ -1655,7 +1655,7 @@
       of_int_floor_le of_rat_of_int_eq real_less_eq_code)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1731,7 +1731,7 @@
 lemmas [nitpick_unfold] = inverse_real_inst.inverse_real one_real_inst.one_real
   ord_real_inst.less_real ord_real_inst.less_eq_real plus_real_inst.plus_real
   times_real_inst.times_real uminus_real_inst.uminus_real
-  zero_real_inst.zero_real
+  zero_real_inst.zero_real*)
 
 
 subsection \<open>Setup for SMT\<close>
diff -urNx '*~' ./String.thy /cygdrive/c/Isabelle2022/src/HOL/String.thy
--- ./String.thy	2023-05-30 11:50:00.046418000 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/String.thy	2023-05-31 17:18:55.605821500 +0900
@@ -40,11 +40,21 @@
 
 lemma (in comm_semiring_1) of_nat_of_char:
   \<open>of_nat (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(* this is more explicit:
+ by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_nat_add of_nat_mult of_nat_of_bool of_nat_numeral of_nat_0)
+*)
 
 lemma (in comm_ring_1) of_int_of_char:
   \<open>of_int (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(*
+  by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_int_add of_int_mult of_int_of_bool of_int_numeral of_int_0)
+*)
 
 lemma nat_of_char [simp]:
   \<open>nat (of_char c) = of_char c\<close>
@@ -698,9 +708,9 @@
 
 lemma [code]:
   \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
-    [foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
+    [foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
 proof -
-  have \<open>foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
+  have \<open>foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
     by simp
   moreover have \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
     [of_char (Char b0 b1 b2 b3 b4 b5 b6 False)] + s\<close>
diff -urNx '*~' ./Tools/Predicate_Compile/predicate_compile_compilations.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML
--- ./Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-30 11:49:58.264752400 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_compilations.ML	2023-05-31 14:26:38.908985500 +0900
@@ -76,21 +76,21 @@
       (Type ("fun", [Type ("fun", [T, \<^typ>\<open>term list option\<close>]), \<^typ>\<open>term list option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
@@ -98,7 +98,7 @@
 fun mk_not t =
   let
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.cps_not\<close>, T --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.cps_not\<close>, T --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -127,33 +127,33 @@
   \<^typ>\<open>natural => (bool * term list) option\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], [])
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.pos_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.pos_bound_cps_plus\<close>
 
 fun mk_if cond =
-  Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_if\<close>,
+  Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_if\<close>,
     HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented yet"
 
 fun mk_not t =
   let
-    val nT = \<^typ>\<open>(unit Quickcheck_Exhaustive.unknown =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued) => natural =>
-      Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+    val nT = \<^typ>\<open>(unit Random_Prep.unknown =>
+      Code_Evaluation.term list Random_Prep.three_valued) => natural =>
+      Code_Evaluation.term list Random_Prep.three_valued\<close>
     val T = mk_monadT HOLogic.unitT
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.pos_bound_cps_not\<close>, nT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.pos_bound_cps_not\<close>, nT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
@@ -176,31 +176,31 @@
 struct
 
 fun mk_monadT T =
-  (Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T])
-    --> \<^typ>\<open>Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>)
-    --> \<^typ>\<open>natural => Code_Evaluation.term list Quickcheck_Exhaustive.three_valued\<close>
+  (Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T])
+    --> \<^typ>\<open>Code_Evaluation.term list Random_Prep.three_valued\<close>)
+    --> \<^typ>\<open>natural => Code_Evaluation.term list Random_Prep.three_valued\<close>
 
 fun dest_monadT
-    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Quickcheck_Exhaustive.unknown\<close>, [T]),
-      \<^typ>\<open>term list Quickcheck_Exhaustive.three_valued\<close>]),
-      \<^typ>\<open>natural => term list Quickcheck_Exhaustive.three_valued\<close>])) = T
+    (Type ("fun", [Type ("fun", [Type (\<^type_name>\<open>Random_Prep.unknown\<close>, [T]),
+      \<^typ>\<open>term list Random_Prep.three_valued\<close>]),
+      \<^typ>\<open>natural => term list Random_Prep.three_valued\<close>])) = T
   | dest_monadT T = raise TYPE ("dest_monadT", [T], []);
 
-fun mk_empty T = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_empty\<close>, mk_monadT T)
+fun mk_empty T = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_empty\<close>, mk_monadT T)
 
 fun mk_single t =
   let val T = fastype_of t
-  in Const(\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
+  in Const(\<^const_name>\<open>Random_Prep.neg_bound_cps_single\<close>, T --> mk_monadT T) $ t end
 
 fun mk_bind (x, f) =
   let val T as Type ("fun", [_, U]) = fastype_of f
   in
-    Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
+    Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_bind\<close>, fastype_of x --> T --> U) $ x $ f
   end;
 
-val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_plus\<close>
+val mk_plus = HOLogic.mk_binop \<^const_name>\<open>Random_Prep.neg_bound_cps_plus\<close>
 
-fun mk_if cond = Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_if\<close>,
+fun mk_if cond = Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_if\<close>,
   HOLogic.boolT --> mk_monadT HOLogic.unitT) $ cond
 
 fun mk_iterate_upto _ _ = error "not implemented"
@@ -210,7 +210,7 @@
     val T = mk_monadT HOLogic.unitT
     val pT = \<^typ>\<open>(unit => (bool * Code_Evaluation.term list) option)\<close>
       --> \<^typ>\<open>natural => (bool * Code_Evaluation.term list) option\<close>
-  in Const (\<^const_name>\<open>Quickcheck_Exhaustive.neg_bound_cps_not\<close>, pT --> T) $ t end
+  in Const (\<^const_name>\<open>Random_Prep.neg_bound_cps_not\<close>, pT --> T) $ t end
 
 fun mk_Enum _ = error "not implemented"
 
diff -urNx '*~' ./Tools/Predicate_Compile/predicate_compile_core.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML
--- ./Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-30 11:49:58.043626700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Predicate_Compile/predicate_compile_core.ML	2023-05-31 14:26:38.908985500 +0900
@@ -435,7 +435,7 @@
   compfuns = Random_Sequence_CompFuns.compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -472,7 +472,7 @@
   compfuns = New_Pos_Random_Sequence_CompFuns.depth_limited_compfuns,
   mk_random = (fn T => fn _ =>
   let
-    val random = Const (\<^const_name>\<open>Quickcheck_Random.random\<close>,
+    val random = Const (\<^const_name>\<open>Random_Prep.random\<close>,
       \<^typ>\<open>natural\<close> --> \<^typ>\<open>Random.seed\<close> -->
         HOLogic.mk_prodT (HOLogic.mk_prodT (T, \<^typ>\<open>unit => term\<close>), \<^typ>\<open>Random.seed\<close>))
   in
@@ -536,7 +536,7 @@
   compfuns = Pos_Bounded_CPS_Comp_Funs.compfuns,
   mk_random =
     (fn T => fn _ =>
-       Const (\<^const_name>\<open>Quickcheck_Exhaustive.exhaustive\<close>,
+       Const (\<^const_name>\<open>Random_Prep.exhaustive\<close>,
        (T --> \<^typ>\<open>(bool * term list) option\<close>) -->
          \<^typ>\<open>natural => (bool * term list) option\<close>)),
   modify_funT = I,
diff -urNx '*~' ./Tools/Quickcheck/random_generators.ML /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML
--- ./Tools/Quickcheck/random_generators.ML	2023-05-30 11:50:41.406853100 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Tools/Quickcheck/random_generators.ML	2023-05-31 14:26:38.908985500 +0900
@@ -204,7 +204,7 @@
         val T = Type (tyco, Ts);
         fun mk_random_fun_lift [] t = t
           | mk_random_fun_lift (fT :: fTs) t =
-              mk_const \<^const_name>\<open>random_fun_lift\<close> [fTs ---> T, fT] $
+              mk_const \<^const_name>\<open>Random_Prep.random_fun_lift\<close> [fTs ---> T, fT] $
                 mk_random_fun_lift fTs t;
         val t = mk_random_fun_lift fTs (nth random_auxs k $ size_pred $ size');
         val size = Option.map snd (Old_Datatype_Aux.find_shortest_path descr k)
diff -urNx '*~' ./Transcendental.thy /cygdrive/c/Isabelle2022/src/HOL/Transcendental.thy
--- ./Transcendental.thy	2023-05-30 11:50:41.644512700 +0900
+++ /cygdrive/c/Isabelle2022/src/HOL/Transcendental.thy	2023-05-31 14:26:38.908985500 +0900
@@ -3422,12 +3422,14 @@
     have "(-1) ^ ((n - Suc 0) div 2) * (-1) ^ ((p - Suc n) div 2) = - ((-1 :: real) ^ (p div 2))"
       if np: "odd n" "even p"
     proof -
-      have "p > 0"
-        using \<open>n \<le> p\<close> neq0_conv that(1) by blast
+      have n1: "Suc 0 \<le>  n" using odd_pos[OF that(1)] by simp
+      have opn: "odd (p - n)" using np \<open>n \<le> p\<close> by simp
+      have snp: "Suc n \<le> p" using odd_pos[OF opn] by simp
+      then have p2: "2 \<le> p" using \<open>n \<le> p\<close> that(2) by (auto elim: oddE)
       then have \<section>: "(- 1::real) ^ (p div 2 - Suc 0) = - ((- 1) ^ (p div 2))"
-        using \<open>even p\<close> by (auto simp add: dvd_def power_eq_if)
-      from \<open>n \<le> p\<close> np have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" "Suc (Suc 0) \<le> p"
-        by arith+
+        by (simp add: power_eq_if)
+      from n1 p2 snp have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" 
+        by simp
       have "(p - Suc (Suc 0)) div 2 = p div 2 - Suc 0"
         by simp
       with \<open>n \<le> p\<close> np  \<section> * show ?thesis
