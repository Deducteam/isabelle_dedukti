diff -urNx '*~' ./Enum.thy /Applications/Isabelle2022.app/src/HOL/Enum.thy
--- ./Enum.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Enum.thy	2023-06-05 09:48:57.000000000 +0900
@@ -929,15 +929,47 @@
 definition "x mod y = (case y of a\<^sub>1 \<Rightarrow> x | _ \<Rightarrow> a\<^sub>1)"
 definition "abs = (\<lambda>x. case x of a\<^sub>3 \<Rightarrow> a\<^sub>2 | _ \<Rightarrow> x)"
 definition "sgn = (\<lambda>x :: finite_3. x)"
+
+lemmas [simp] = times_finite_3_def plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+  inverse_finite_3_def divide_finite_3_def sgn_finite_3_def abs_finite_3_def modulo_finite_3_def
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: plus_finite_3_def uminus_finite_3_def minus_finite_3_def
-        times_finite_3_def
-        inverse_finite_3_def divide_finite_3_def modulo_finite_3_def
-        abs_finite_3_def sgn_finite_3_def
-        less_finite_3_def
-        split: finite_3.splits\<close>)
+    apply standard
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal by simp
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  done
+
+lemmas [simp del] = times_finite_3_def plus_finite_3_def uminus_finite_3_def minus_finite_3_def
+  inverse_finite_3_def divide_finite_3_def sgn_finite_3_def abs_finite_3_def modulo_finite_3_def
+
 end
 
 lemma two_finite_3 [simp]:
@@ -953,17 +985,30 @@
 definition [simp]: "unit_factor = (id :: finite_3 \<Rightarrow> _)"
 definition [simp]: "euclidean_size x = (case x of a\<^sub>1 \<Rightarrow> 0 | _ \<Rightarrow> 1)"
 definition [simp]: "division_segment (x :: finite_3) = 1"
+
+lemmas [simp] = divide_finite_3_def times_finite_3_def
+      dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
 instance
-proof
-  fix x :: finite_3
-  assume "x \<noteq> 0"
-  then show "is_unit (unit_factor x)"
-    by (cases x) (simp_all add: dvd_finite_3_unfold)
-qed
-  (subproofs
-    \<open>auto simp add: divide_finite_3_def times_finite_3_def
+   apply intro_classes
+  subgoal by simp
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  done
+
+lemmas [simp del] = divide_finite_3_def times_finite_3_def
       dvd_finite_3_unfold inverse_finite_3_def plus_finite_3_def
-      split: finite_3.splits\<close>)
+
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3
@@ -1034,11 +1079,33 @@
   | (a\<^sub>3, _) \<Rightarrow> a\<^sub>3 | (_, a\<^sub>3) \<Rightarrow> a\<^sub>3
   | _ \<Rightarrow> a\<^sub>1)"
 
+lemmas [simp] = less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
+        inf_finite_4_def sup_finite_4_def
+
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
-        inf_finite_4_def sup_finite_4_def split: finite_4.splits\<close>)
+  apply intro_classes
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  done
+
+lemmas [simp del] = less_finite_4_def less_eq_finite_4_def Inf_finite_4_def Sup_finite_4_def 
+        inf_finite_4_def sup_finite_4_def
+
 end
 
 instance finite_4 :: complete_lattice ..
@@ -1048,11 +1115,14 @@
 instantiation finite_4 :: complete_boolean_algebra begin
 definition "- x = (case x of a\<^sub>1 \<Rightarrow> a\<^sub>4 | a\<^sub>2 \<Rightarrow> a\<^sub>3 | a\<^sub>3 \<Rightarrow> a\<^sub>2 | a\<^sub>4 \<Rightarrow> a\<^sub>1)"
 definition "x - y = x \<sqinter> - (y :: finite_4)"
+lemmas [simp] =  inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def
 instance
-  by standard
-    (subproofs
-      \<open>simp_all add: inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def 
-        split: finite_4.splits\<close>)
+  apply intro_classes
+  subgoal for a by (cases a; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  done
+lemmas [simp del] =  inf_finite_4_def sup_finite_4_def uminus_finite_4_def minus_finite_4_def
 end
 
 hide_const (open) a\<^sub>1 a\<^sub>2 a\<^sub>3 a\<^sub>4
@@ -1138,11 +1208,30 @@
    | (a\<^sub>4, _) \<Rightarrow> a\<^sub>4 | (_, a\<^sub>4) \<Rightarrow> a\<^sub>4
    | _ \<Rightarrow> a\<^sub>1)"
 
+lemmas [simp] = less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
+        Inf_finite_5_def Sup_finite_5_def
 instance
-  by standard
-    (subproofs
-      \<open>auto simp add: less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
-        Inf_finite_5_def Sup_finite_5_def split: finite_5.splits if_split_asm\<close>)
+  apply intro_classes
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a by (cases a; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b by (cases a; cases b; simp)
+  subgoal for a b c by (cases a; cases b; cases c; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal for a by (cases a; simp)
+  subgoal by simp
+  subgoal by simp
+  done
+lemmas [simp del] = less_eq_finite_5_def less_finite_5_def inf_finite_5_def sup_finite_5_def 
+        Inf_finite_5_def Sup_finite_5_def
+
 end
 
 
diff -urNx '*~' ./Euclidean_Division.thy /Applications/Isabelle2022.app/src/HOL/Euclidean_Division.thy
--- ./Euclidean_Division.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Euclidean_Division.thy	2023-06-05 09:48:57.000000000 +0900
@@ -1684,7 +1684,8 @@
 lemma divide_int_unfold:
   \<open>(sgn k * int m) div (sgn l * int n) = (sgn k * sgn l * int (m div n)
     - of_bool ((k = 0 \<longleftrightarrow> m = 0) \<and> l \<noteq> 0 \<and> n \<noteq> 0 \<and> sgn k \<noteq> sgn l \<and> \<not> n dvd m))\<close>
-  by (simp add: divide_int_def sgn_mult nat_mult_distrib abs_mult sgn_eq_0_iff ac_simps)
+  apply (cases "k = 0"; cases "m = 0"; cases "l = 0"; cases "n = 0")
+  by (simp_all add: divide_int_def sgn_mult nat_mult_distrib abs_mult sgn_eq_0_iff)
 
 definition modulo_int :: \<open>int \<Rightarrow> int \<Rightarrow> int\<close>
   where \<open>k mod l = sgn k * int (nat \<bar>k\<bar> mod nat \<bar>l\<bar>) + l * of_bool (sgn k \<noteq> sgn l \<and> \<not> l dvd k)\<close>
@@ -1692,6 +1693,7 @@
 lemma modulo_int_unfold:
   \<open>(sgn k * int m) mod (sgn l * int n) =
     sgn k * int (m mod (of_bool (l \<noteq> 0) * n)) + (sgn l * int n) * of_bool ((k = 0 \<longleftrightarrow> m = 0) \<and> sgn k \<noteq> sgn l \<and> \<not> n dvd m)\<close>
+  apply (cases "k = 0"; cases "m = 0"; cases "l = 0"; cases "n = 0")
   by (auto simp add: modulo_int_def sgn_mult abs_mult)
 
 instance proof
@@ -2795,8 +2797,8 @@
   finally have *: \<open>\<bar>k\<bar> div \<bar>l\<bar> \<noteq> 0 \<longleftrightarrow> \<bar>l\<bar> \<le> \<bar>k\<bar>\<close> .
   show ?thesis
     using \<open>0 \<le> \<bar>k\<bar> div \<bar>l\<bar>\<close> False
-  by (auto simp add: div_eq_div_abs [of k l] div_eq_sgn_abs [of k l]
-    sgn_mult sgn_1_pos sgn_1_neg sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest: sgn_not_eq_imp)
+  by (auto simp add: div_eq_div_abs [of k l] (* redundant and looping! div_eq_sgn_abs [of k l] *)
+    sgn_mult sgn_eq_0_iff nonneg1_imp_zdiv_pos_iff * dest!: sgn_not_eq_imp)
 qed
 
 
diff -urNx '*~' ./Factorial.thy /Applications/Isabelle2022.app/src/HOL/Factorial.thy
--- ./Factorial.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Factorial.thy	2023-06-05 09:48:57.000000000 +0900
@@ -28,7 +28,7 @@
   have "prod Suc {0..<n} = \<Prod>{1..n}"
     by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
   then have "prod Suc {0..<n} = prod ((-) (n + 1)) {1..n}"
-    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by presburger
+    using prod.atLeastAtMost_rev [of "\<lambda>i. i" 1 n] by auto
   then show ?thesis
     unfolding fact_prod_Suc by (simp add: atLeast0LessThan prod.atLeast1_atMost_eq)
 qed
diff -urNx '*~' ./Groups_List.thy /Applications/Isabelle2022.app/src/HOL/Groups_List.thy
--- ./Groups_List.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Groups_List.thy	2023-06-05 09:48:57.000000000 +0900
@@ -3,7 +3,7 @@
 section \<open>Sum and product over lists\<close>
 
 theory Groups_List
-imports List
+imports List Divides
 begin
 
 locale monoid_list = monoid
diff -urNx '*~' ./Library/Code_Abstract_Char.thy /Applications/Isabelle2022.app/src/HOL/Library/Code_Abstract_Char.thy
--- ./Library/Code_Abstract_Char.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Code_Abstract_Char.thy	2023-07-03 14:16:25.000000000 +0900
@@ -30,7 +30,7 @@
 qed
 
 definition byte :: \<open>bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> integer\<close>
-  where [simp]: \<open>byte b0 b1 b2 b3 b4 b5 b6 b7 = horner_sum of_bool 2 [b0, b1, b2, b3, b4, b5, b6, b7]\<close>
+  where [simp]: \<open>byte b0 b1 b2 b3 b4 b5 b6 b7 = horner_sum of_bool 2 [b0, b1, b2, b3, b4, b5, b6, b7]\<close> 
 
 lemma byte_code [code]:
   \<open>byte b0 b1 b2 b3 b4 b5 b6 b7 = (
@@ -44,7 +44,7 @@
       s6 = if b6 then s5 + 64 else s5;
       s7 = if b7 then s6 + 128 else s6
     in s7)\<close>
-  by simp
+  by (simp add: Let_unfold)
 
 lemma Char_code [code]:
   \<open>integer_of_char (Char b0 b1 b2 b3 b4 b5 b6 b7) = byte b0 b1 b2 b3 b4 b5 b6 b7\<close>
@@ -52,35 +52,51 @@
 
 lemma digit_0_code [code]:
   \<open>digit0 c \<longleftrightarrow> bit (integer_of_char c) 0\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma digit_1_code [code]:
   \<open>digit1 c \<longleftrightarrow> bit (integer_of_char c) 1\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma digit_2_code [code]:
   \<open>digit2 c \<longleftrightarrow> bit (integer_of_char c) 2\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma digit_3_code [code]:
   \<open>digit3 c \<longleftrightarrow> bit (integer_of_char c) 3\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma digit_4_code [code]:
   \<open>digit4 c \<longleftrightarrow> bit (integer_of_char c) 4\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma digit_5_code [code]:
   \<open>digit5 c \<longleftrightarrow> bit (integer_of_char c) 5\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma digit_6_code [code]:
   \<open>digit6 c \<longleftrightarrow> bit (integer_of_char c) 6\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma digit_7_code [code]:
   \<open>digit7 c \<longleftrightarrow> bit (integer_of_char c) 7\<close>
-  by (cases c) (simp add: integer_of_char_def)
+  apply (cases c)
+  by (simp only: Char_code bit_horner_sum_bit_iff byte_def; simp)
+(*  by (cases c) (simp add: integer_of_char_def)*)
 
 lemma case_char_code [code]:
   \<open>case_char f c = f (digit0 c) (digit1 c) (digit2 c) (digit3 c) (digit4 c) (digit5 c) (digit6 c) (digit7 c)\<close>
diff -urNx '*~' ./Library/Countable_Set_Type.thy /Applications/Isabelle2022.app/src/HOL/Library/Countable_Set_Type.thy
--- ./Library/Countable_Set_Type.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Countable_Set_Type.thy	2023-07-05 11:38:18.000000000 +0900
@@ -99,7 +99,37 @@
 lift_definition minus_cset :: "'a cset \<Rightarrow> 'a cset \<Rightarrow> 'a cset"
 is minus parametric Diff_transfer by simp
 
-instance by standard (transfer; auto)+
+instance 
+proof (standard)
+  fix x :: "'a cset"
+  show "x \<le> x"
+    by (transfer; simp)
+  show "bot \<le> x"
+    by (transfer; simp)
+  fix y :: "'a cset"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)"
+    by (transfer; simp add: subset_not_subset_eq)
+  show "inf x y \<le> x"
+    by (transfer; simp)
+  show "inf x y \<le> y"
+    by (transfer; simp)
+  show "x \<le> sup x y"
+    by (transfer; simp)
+  show "y \<le> sup x y"
+    by (transfer; simp)
+  fix z :: "'a cset"
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z"
+    by (transfer; simp)
+  show "x \<le> y \<Longrightarrow>y \<le> x \<Longrightarrow> x = y"
+    by (transfer; simp)
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> inf y z"
+    by (transfer; simp)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> sup y z \<le> x"
+    by (transfer; simp)
+  show "sup x (inf y z) = inf (sup x y) (sup x z)"
+    by (transfer; simp add: Un_Int_distrib)
+qed
+(*  by standard (transfer; auto)+*)
 
 end
 
@@ -472,7 +502,8 @@
 lemma cUnion_parametric [transfer_rule]:
   "(rel_cset (rel_cset A) ===> rel_cset A) cUnion cUnion"
   unfolding rel_fun_def
-  by transfer (auto simp: rel_set_def, metis+)
+  by transfer (metis Union_transfer rel_fun_def)
+(*  by transfer (auto simp: rel_set_def, metis+)*)
 
 lemma cimage_parametric [transfer_rule]:
   "((A ===> B) ===> rel_cset A ===> rel_cset B) cimage cimage"
diff -urNx '*~' ./Library/Dlist.thy /Applications/Isabelle2022.app/src/HOL/Library/Dlist.thy
--- ./Library/Dlist.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Dlist.thy	2023-07-03 14:21:39.000000000 +0900
@@ -226,7 +226,7 @@
 
 subsection \<open>Quickcheck generators\<close>
 
-quickcheck_generator dlist predicate: distinct constructors: Dlist.empty, Dlist.insert
+(*quickcheck_generator dlist predicate: distinct constructors: Dlist.empty, Dlist.insert*)
 
 subsection \<open>BNF instance\<close>
 
diff -urNx '*~' ./Library/Equipollence.thy /Applications/Isabelle2022.app/src/HOL/Library/Equipollence.thy
--- ./Library/Equipollence.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Equipollence.thy	2023-07-03 16:35:03.000000000 +0900
@@ -131,15 +131,49 @@
 lemma infinite_insert_lepoll:
   assumes "infinite A" shows "insert a A \<lesssim> A"
 proof -
-  obtain f :: "nat \<Rightarrow> 'a" where "inj f" and f: "range f \<subseteq> A"
+  obtain f :: "nat \<Rightarrow> 'a" where injf: "inj f" and f: "range f \<subseteq> A"
     using assms infinite_countable_subset by blast
-  let ?g = "(\<lambda>z. if z=a then f 0 else if z \<in> range f then f (Suc (inv f z)) else z)"
+  let ?g = "(\<lambda>z. if z=a then f 0 else if z \<in> range f then (f \<circ> (Suc \<circ> (inv f))) z else z)"
   show ?thesis
     unfolding lepoll_def
   proof (intro exI conjI)
+    from injf have "inj_on (inv f) (range f)"
+      by (simp add: inj_on_inv_into)
+    from comp_inj_on[OF this inj_Suc]
+    have "inj_on (Suc \<circ> (inv f)) (range f)" by auto
+    from comp_inj_on[OF this inj_on_subset[OF injf]]
+    have *: "inj_on (f \<circ> (Suc \<circ> (inv f))) (range f)" by auto
+    have **: "(f \<circ> (Suc \<circ> inv f)) ` range f \<inter> id ` (A - range f) = {}" by force
+    have "range f \<union> (A - range f) = A"
+      using f by auto
+    with ** inj_on_disjoint_Un[OF * inj_on_id2[of "A-(range f)"]]
+    have ***: "inj_on (\<lambda>z. if z \<in> range f then (f \<circ> (Suc \<circ> (inv f))) z else z) A"
+      by auto
+    have "f 0 \<notin> (\<lambda>z. if z \<in> range f then (f \<circ> (Suc \<circ> inv f)) z else z) ` A"
+    proof(rule ccontr)
+      assume "\<not> f 0 \<notin> (\<lambda>z. if z \<in> range f then (f \<circ> (Suc \<circ> inv f)) z else z) ` A"
+      then obtain x where "x \<in> A" and f0: "(\<lambda>z. if z \<in> range f then (f \<circ> (Suc \<circ> inv f)) z else z) x = f 0" 
+        by auto
+      show False
+      proof (cases "x \<in> range f")
+        case True
+        with f0 have "f 0 = (f \<circ> (Suc \<circ> inv f)) x" by auto
+        with injf have "0 = (Suc \<circ> inv f) x"
+          by (metis comp_apply inv_f_f)
+        then show ?thesis by auto
+      next
+        case False
+        with f0 have "f 0 = x" by auto
+        with False show ?thesis by auto
+      qed
+    qed
+    then have "(\<lambda>z. f 0) ` {a} \<inter> (\<lambda>z. if z \<in> range f then (f \<circ> (Suc \<circ> inv f)) z else z) ` A = {}" 
+      by auto  
+    with inj_on_disjoint_Un[of "\<lambda>z. f 0" "{a}", OF _ ***]
     show "inj_on ?g (insert a A)"
-      using inj_on_eq_iff [OF \<open>inj f\<close>]
-      by (auto simp: inj_on_def)
+      by auto
+      (*using inj_on_eq_iff [OF \<open>inj f\<close>]
+      by (auto simp: inj_on_def inj_on_disjoint_Un)*)
     show "?g ` insert a A \<subseteq> A"
       using f by auto
   qed
diff -urNx '*~' ./Library/Extended.thy /Applications/Isabelle2022.app/src/HOL/Library/Extended.thy
--- ./Library/Extended.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Extended.thy	2023-07-03 12:36:29.000000000 +0900
@@ -26,12 +26,32 @@
 "((x::'a extended) < y) = (x \<le> y \<and> \<not> y \<le> x)"
 
 instance
-  by intro_classes (auto simp: less_extended_def less_eq_extended_case split: extended.splits)
+proof(intro_classes)
+  fix x :: "'a extended"
+  show "x \<le> x" 
+    by (cases x; simp add: less_eq_extended_case)
+next
+  fix x y :: "'a extended"
+  show "(x < y) = (x \<le> y \<and>  \<not> y \<le> x)"
+    by (cases x; cases y; simp add: less_eq_extended_case less_extended_def)
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y"
+    by (cases x; cases y; simp add: less_eq_extended_case)
+next
+  fix x y z :: "'a extended"
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z"
+    by (cases x; cases y; cases z; simp add: less_eq_extended_case)
+qed
+(*  by intro_classes (auto simp: less_extended_def less_eq_extended_case split: extended.splits)*)
 
 end
 
 instance extended :: (linorder)linorder
-  by intro_classes (auto simp: less_eq_extended_case split:extended.splits)
+proof(intro_classes)
+  fix x y :: "'a extended"
+  show "x \<le> y \<or> y \<le> x"
+    by (cases x; cases y; simp add: linear less_eq_extended_case)
+qed
+(*  by intro_classes (auto simp: less_eq_extended_case split:extended.splits)*)
 
 lemma Minf_le[simp]: "Minf \<le> y"
 by(cases y) auto
@@ -111,10 +131,23 @@
 
 
 instance extended :: (ab_semigroup_add)ab_semigroup_add
-  by intro_classes (simp_all add: ac_simps plus_case split: extended.splits)
+proof(intro_classes)
+  fix a b :: "'a extended"
+  show "a + b = b + a"
+    by (cases a; cases b; simp add: ac_simps plus_case)
+  fix c :: "'a extended"
+  show "a + b + c = a + (b + c)"
+    by (cases a; cases b; cases c; simp add: ac_simps plus_case)
+qed
+(*  by intro_classes (simp_all add: ac_simps plus_case split: extended.splits)*)
 
 instance extended :: (ordered_ab_semigroup_add)ordered_ab_semigroup_add
-  by intro_classes (auto simp: add_left_mono plus_case split: extended.splits)
+proof(intro_classes)
+  fix a b c :: "'a extended"
+  show "a \<le> b \<Longrightarrow> c + a \<le> c + b"
+    by (cases a; cases b; cases c; simp add: add_left_mono plus_case)
+qed
+(*  by intro_classes (auto simp: add_left_mono plus_case split: extended.splits)*)
 
 instance extended :: (comm_monoid_add)comm_monoid_add
 proof
@@ -191,8 +224,29 @@
 case_of_simps sup_extended_case: sup_extended.simps
 
 instance
-  by (intro_classes) (auto simp: inf_extended_case sup_extended_case less_eq_extended_case
-    bot_extended_def top_extended_def split: extended.splits)
+proof(intro_classes)
+  fix x :: "'a extended"
+  show "bot \<le> x" 
+    by (cases x; simp add: bot_extended_def less_eq_extended_case)
+  show "x \<le> top" 
+    by (cases x; simp add: top_extended_def less_eq_extended_case)
+  fix y :: "'a extended"
+  show "inf x y \<le> x" 
+    by (cases x; cases y; simp add: inf_extended_case less_eq_extended_case)
+  show "inf x y \<le> y" 
+    by (cases x; cases y; simp add: inf_extended_case less_eq_extended_case)
+  show "x \<le> sup x y" 
+    by (cases x; cases y; simp add: sup_extended_case less_eq_extended_case)
+  show "y \<le> sup x y" 
+    by (cases x; cases y; simp add: sup_extended_case less_eq_extended_case)
+  fix z :: "'a extended"
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> inf y z"
+    by (cases x; cases y; cases z; simp add: inf_extended_case less_eq_extended_case)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> sup y z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_extended_case less_eq_extended_case)
+qed
+(*  by (intro_classes) (auto simp: inf_extended_case sup_extended_case less_eq_extended_case
+    bot_extended_def top_extended_def split: extended.splits)*)
 end
 
 end
diff -urNx '*~' ./Library/Extended_Nat.thy /Applications/Isabelle2022.app/src/HOL/Library/Extended_Nat.thy
--- ./Library/Extended_Nat.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Extended_Nat.thy	2023-07-05 12:15:04.000000000 +0900
@@ -218,7 +218,8 @@
   fix a b c :: enat
   show "(a * b) * c = a * (b * c)"
     unfolding times_enat_def zero_enat_def
-    by (simp split: enat.split)
+    by (cases a b c rule: enat3_cases; simp)
+    (*by (simp split: enat.split)*)
   show comm: "a * b = b * a"
     unfolding times_enat_def zero_enat_def
     by (simp split: enat.split)
@@ -227,7 +228,8 @@
     by (simp split: enat.split)
   show distr: "(a + b) * c = a * c + b * c"
     unfolding times_enat_def zero_enat_def
-    by (simp split: enat.split add: distrib_right)
+    by (cases a b c rule: enat3_cases;simp add: distrib_right)
+    (*by (simp split: enat.split add: distrib_right)*)
   show "0 * a = 0"
     unfolding times_enat_def zero_enat_def
     by (simp split: enat.split)
@@ -323,6 +325,7 @@
 lemma eSuc_minus_1 [simp]: "eSuc n - 1 = n"
   by (simp add: one_enat_def flip: eSuc_enat zero_enat_def)
 
+(*do not touch this comment*)
 (*lemmas idiff_self_eq_0_enat = idiff_self_eq_0[unfolded zero_enat_def]*)
 
 subsection \<open>Ordering\<close>
@@ -380,7 +383,8 @@
   fix a b c :: enat
   show "a \<le> b \<Longrightarrow> 0 \<le> c \<Longrightarrow>c * a \<le> c * b"
     unfolding times_enat_def less_eq_enat_def zero_enat_def
-    by (simp split: enat.splits)
+    by (cases a b c rule: enat3_cases;simp)
+    (*by (simp split: enat.splits)*)
   show "a < b \<Longrightarrow> c < d \<Longrightarrow> a + c < b + d" for a b c d :: enat
     by (cases a b c d rule: enat2_cases[case_product enat2_cases]) auto
   show "a < b \<Longrightarrow> a + 1 < b + 1"
diff -urNx '*~' ./Library/Extended_Real.thy /Applications/Isabelle2022.app/src/HOL/Library/Extended_Real.thy
--- ./Library/Extended_Real.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Extended_Real.thy	2023-07-05 12:50:39.000000000 +0900
@@ -2045,10 +2045,10 @@
     then have "0 < - c" "- c < \<infinity>"
       by (auto simp: ereal_uminus_reorder ereal_less_uminus_reorder[of 0])
     then have "((\<lambda>x. (- c) * f x) \<longlongrightarrow> (- c) * x) F"
-      by (rule *)
+      by (rule * )
     from tendsto_uminus_ereal[OF this] show ?thesis
       by simp
-  qed (auto intro!: *)
+  qed (auto intro!: * )
 qed
 
 lemma tendsto_cmult_ereal_not_0[tendsto_intros, simp, intro]:
@@ -2364,11 +2364,11 @@
       by (cases a b rule: ereal2_cases) auto }
   note * = this
   have "(INF i. f i + g i) = (INF i. - ((- f i) + (- g i)))"
-    by (simp add: fin *)
+    by (simp add: fin * )
   also have "\<dots> = Inf (f ` UNIV) + Inf (g ` UNIV)"
     unfolding ereal_INF_uminus_eq
     using assms INF_less
-    by (subst SUP_ereal_add) (auto simp: ereal_SUP_uminus fin *)
+    by (subst SUP_ereal_add) (auto simp: ereal_SUP_uminus fin * )
   finally show ?thesis .
 qed
 
@@ -2675,7 +2675,7 @@
   have *: "A = ereal ` (ereal -` A) \<union> (if \<infinity> \<in> A then {ereal x<..} else {}) \<union> (if -\<infinity> \<in> A then {..< ereal y} else {})"
     using A(2,3) by auto
   from open_ereal[OF A(1)] show "open A"
-    by (subst *) (auto simp: open_Un)
+    by (subst * ) (auto simp: open_Un)
 qed
 
 lemma open_PInfty2:
@@ -3509,7 +3509,7 @@
   show ?thesis
     using assms
     apply (subst (1 2) suminf_ereal_eq_SUP)
-    apply (auto intro!: SUP_upper2 SUP_commute simp: *)
+    apply (auto intro!: SUP_upper2 SUP_commute simp: * )
     done
 qed
 
diff -urNx '*~' ./Library/FSet.thy /Applications/Isabelle2022.app/src/HOL/Library/FSet.thy
--- ./Library/FSet.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/FSet.thy	2023-07-05 14:28:20.000000000 +0900
@@ -53,8 +53,36 @@
   by simp
 
 instance
-  by (standard; transfer; auto)+
-
+proof (standard)
+  fix x :: "'a fset"
+  show "x \<le> x"
+    by (transfer; simp)
+  show "bot \<le> x"
+    by (transfer; simp)
+  fix y :: "'a fset"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)"
+    by (transfer; simp add: subset_not_subset_eq)
+  show "inf x y \<le> x"
+    by (transfer; simp)
+  show "inf x y \<le> y"
+    by (transfer; simp)
+  show "x \<le> sup x y"
+    by (transfer; simp)
+  show "y \<le> sup x y"
+    by (transfer; simp)
+  fix z :: "'a fset"
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z"
+    by (transfer; simp)
+  show "x \<le> y \<Longrightarrow>y \<le> x \<Longrightarrow> x = y"
+    by (transfer; simp)
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> inf y z"
+    by (transfer; simp)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> sup y z \<le> x"
+    by (transfer; simp)
+  show "sup x (inf y z) = inf (sup x y) (sup x z)"
+    by (transfer; simp add: Un_Int_distrib)
+qed
+(*  by (standard; transfer; auto)+*)
 end
 
 abbreviation fempty :: "'a fset" ("{||}") where "{||} \<equiv> bot"
@@ -1022,7 +1050,9 @@
 
 lemma ffUnion_transfer [transfer_rule]:
   "(rel_fset (rel_fset A) ===> rel_fset A) ffUnion ffUnion"
-  unfolding rel_fun_def rel_fset_alt_def by transfer (simp, fast)
+  unfolding rel_fun_def
+  by transfer (metis Union_transfer rel_fun_def)
+(*  unfolding rel_fun_def rel_fset_alt_def by transfer (simp, fast)*)
 
 lemma fimage_transfer [transfer_rule]:
   "((A ===> B) ===> rel_fset A ===> rel_fset B) fimage fimage"
@@ -1146,7 +1176,7 @@
       by (transfer, auto simp add: image_def Int_def split: prod.splits)
     from * show "b = fimage snd R'" using conjunct2[OF \<open>?L\<close>]
       by (transfer, auto simp add: image_def Int_def split: prod.splits)
-  qed (auto simp add: *)
+  qed (auto simp add: * )
 next
   assume ?R thus ?L unfolding Grp_def relcompp.simps conversep.simps
   apply (simp add: subset_eq Ball_def)
@@ -1177,7 +1207,8 @@
 done
 
 lemma rel_fset_fset: "rel_set \<chi> (fset A1) (fset A2) = rel_fset \<chi> A1 A2"
-  by transfer (rule refl)
+  by (simp add: rel_fset.rep_eq)
+(*  by transfer (rule refl)*)
 
 end
 
@@ -1350,7 +1381,7 @@
 
 no_notation Quickcheck_Exhaustive.orelse (infixr "orelse" 55)
 
-instantiation fset :: (random) random
+(*instantiation fset :: (random) random
 begin
 
 context
@@ -1383,6 +1414,6 @@
 
 end
 
-end
+end*)
 
 end
diff -urNx '*~' ./Library/Finite_Map.thy /Applications/Isabelle2022.app/src/HOL/Library/Finite_Map.thy
--- ./Library/Finite_Map.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Finite_Map.thy	2023-07-05 14:41:15.000000000 +0900
@@ -1316,7 +1316,7 @@
 
 
 code_datatype fmap_of_list
-quickcheck_generator fmap constructors: fmap_of_list
+(*quickcheck_generator fmap constructors: fmap_of_list*)
 
 context includes fset.lifting begin
 
@@ -1441,7 +1441,7 @@
   fBall fmrel fmran fmran' fmdom fmdom' fmpred pred_fmap fmsubset fmupd fmrel_on_fset
   fmdrop fmdrop_set fmdrop_fset fmrestrict_set fmrestrict_fset fmimage fmlookup fmempty
   fmfilter fmadd fmmap fmmap_keys fmcomp
-  checking SML Scala Haskell? OCaml?
+  checking (*SML*) Scala Haskell? OCaml?
 
 \<comment> \<open>\<open>lifting\<close> through \<^type>\<open>fmap\<close>\<close>
 
diff -urNx '*~' ./Library/Interval.thy /Applications/Isabelle2022.app/src/HOL/Library/Interval.thy
--- ./Library/Interval.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Interval.thy	2023-07-10 15:50:13.000000000 +0900
@@ -578,18 +578,33 @@
 lemma set_of_distrib_left:
   "set_of (B * (A1 + A2)) \<subseteq> set_of (B * A1 + B * A2)"
   for A1 :: "'a::linordered_ring interval"
-  apply transfer
-  apply (clarsimp simp: Let_def distrib_left distrib_right)
-  apply (intro conjI)
-         apply (metis add_mono min.cobounded1 min.left_commute)
-        apply (metis add_mono min.cobounded1 min.left_commute)
-       apply (metis add_mono min.cobounded1 min.left_commute)
-      apply (metis add_mono min.assoc min.cobounded2)
-     apply (meson add_mono order.trans max.cobounded1 max.cobounded2)
-    apply (meson add_mono order.trans max.cobounded1 max.cobounded2)
-   apply (meson add_mono order.trans max.cobounded1 max.cobounded2)
-  apply (meson add_mono order.trans max.cobounded1 max.cobounded2)
-  done
+proof-
+  define X where "X \<equiv> {(lower B)*(lower A1) + (lower B) * (lower A2),(lower B)*(upper A1) + (lower B)*(upper A2),(upper B)*(lower A1) + (upper B)*(lower A2),(upper B)*(upper A1) + (upper B)*(upper A2)}"
+  define Y1 where "Y1 \<equiv> {(lower B)*(lower A1),(lower B)*(upper A1),(upper B)*(lower A1),(upper B)*(upper A1)}"
+  define Y2 where "Y2 \<equiv> {(lower B)*(lower A2),(lower B)*(upper A2),(upper B)*(lower A2),(upper B)*(upper A2)}"
+  have l1: "lower(B * (A1 + A2)) = Min X"
+    by (simp add: lower_times distrib_left X_def)
+  have l2: "lower (B * A1) = Min Y1"
+    by (simp add: lower_times Y1_def)
+  have l3: "lower(B * A2) = Min Y2"
+    by (simp add: lower_times Y2_def)
+  have l: "lower (B * A1 + B * A2) \<le> lower(B * (A1 + A2))"
+    apply (simp only: l1 X_def, rule Min.boundedI,simp?,auto)
+    using l2 l3 Min.coboundedI[of Y1] Min.coboundedI[of Y2]
+    by (simp_all add: add_mono_thms_linordered_semiring(1) Y1_def Y2_def)
+  have u1: "upper(B * (A1 + A2)) = Max X"
+    by (simp add: upper_times distrib_left X_def)
+  have l2: "upper (B * A1) = Max Y1"
+    by (simp add: upper_times Y1_def)
+  have l3: "upper(B * A2) = Max Y2"
+    by (simp add: upper_times Y2_def)
+  have u: "upper (B * (A1 + A2)) \<le> upper (B * A1 + B * A2)"
+    apply (simp only: u1 X_def, rule Max.boundedI,simp?,auto)
+    using l2 l3 Max.coboundedI[of Y1] Max.coboundedI[of Y2]
+    by (simp_all add: add_mono_thms_linordered_semiring(1) Y1_def Y2_def)
+  with l show ?thesis
+    by (auto simp: set_of_eq)
+qed
 
 lemma set_of_distrib_right:
   "set_of ((A1 + A2) * B) \<subseteq> set_of (A1 * B + A2 * B)"
@@ -757,7 +772,14 @@
 
 lemma split_intervalD: "split_interval X x = (A, B) \<Longrightarrow> set_of X \<subseteq> set_of A \<union> set_of B"
   unfolding set_of_eq
-  by transfer (auto simp: min_def max_def split: if_splits)
+proof (transfer)
+  fix X A B ::"'a \<times> 'a" and x :: "'a" assume "X \<in> {(x, y). x \<le> y}" and "A \<in> {(x, y). x \<le> y}" and "B \<in> {(x, y). x \<le> y}"
+    and *: "(case X of (l, u) \<Rightarrow> \<lambda>x. ((min l x, max l x), min u x, max u x)) x = (A, B)"
+  then obtain l u where X: "X = (l,u)" and "l \<le> u" by auto
+  with * have A: "A = (min l x, max l x)" and B: "B = (min u x, max u x)" by auto
+  with X show "{fst X..snd X} \<subseteq> {fst A..snd A} \<union> {fst B..snd B}"
+    by (cases "l \<le> x"; cases "u \<le> x";auto simp add: min_def max_def)
+qed
 
 instantiation interval :: ("{topological_space, preorder}") topological_space
 begin
diff -urNx '*~' ./Library/Interval_Float.thy /Applications/Isabelle2022.app/src/HOL/Library/Interval_Float.thy
--- ./Library/Interval_Float.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Interval_Float.thy	2023-07-10 17:50:11.000000000 +0900
@@ -121,7 +121,9 @@
   by (auto simp: set_of_eq)
 
 lemma real_interval_times: "real_interval (A * B) = real_interval A * real_interval B"
-  by (auto simp: interval_eq_iff lower_times upper_times min_def max_def)
+  apply (rule interval_eq_iff[THEN iffD2]; intro conjI; simp)
+   apply (auto simp: lower_times min_def)
+  by (auto simp: upper_times max_def)
 
 lemma times_in_float_intervalI: "a * b \<in>\<^sub>r A * B" if "a \<in>\<^sub>r A" "b \<in>\<^sub>r B"
   using times_in_intervalI[OF that]
@@ -294,11 +296,18 @@
   hence "x' \<in>\<^sub>r I" "xs all_in Is"
     using Cons(2)
     by auto
+  from split_correct[OF \<open>x' \<in>\<^sub>r I\<close>] 
+  obtain U where U: "U \<in> set (split I)" "x' \<in>\<^sub>r U"
+    by (auto simp add: list_ex_iff)
+  from Cons(1)[OF \<open>xs all_in Is\<close>] list_ex_iff
+  obtain Y where Y: "Y \<in> set (split_domain split Is)" "xs all_in Y"
+    by (auto simp add: list_ex_iff)
+  from U(1) Y(1)
   show ?case
-    using Cons(1)[OF \<open>xs all_in Is\<close>]
-      split_correct[OF \<open>x' \<in>\<^sub>r I\<close>]
-    apply (auto simp add: list_ex_iff set_of_eq)
-    by (smt (verit, ccfv_SIG) One_nat_def Suc_pred \<open>x \<noteq> []\<close> le_simps(3) length_greater_0_conv length_tl linorder_not_less list.sel(3) neq0_conv nth_Cons' x_decomp)
+    apply (simp add: list_ex_iff;intro bexI[of _ Y] conjI bexI[of _ U] allI;simp)
+    using Y(2) x_decomp apply simp
+    using U(2) Y(2)[THEN all_in_def[THEN iffD1]] x_decomp 
+    by (metis Suc_le_eq less_Suc_eq_le not0_implies_Suc nth_Cons_0 nth_Cons_Suc)
 qed simp
 
 
diff -urNx '*~' ./Library/Lattice_Constructions.thy /Applications/Isabelle2022.app/src/HOL/Library/Lattice_Constructions.thy
--- ./Library/Lattice_Constructions.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Lattice_Constructions.thy	2023-07-03 17:31:50.000000000 +0900
@@ -51,16 +51,37 @@
   by (simp add: less_bot_def)
 
 instance
-  by standard
-    (auto simp add: less_eq_bot_def less_bot_def less_le_not_le elim: order_trans split: bot.splits)
+proof standard
+  fix x :: "'a bot"
+  show "x \<le> x"
+    by (cases x; simp)
+  fix y :: "'a bot"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)" 
+    by (cases x; cases y; simp add: less_le_not_le)
+  fix z :: "'a bot" 
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z"
+    by (cases x; cases y; cases z; auto elim: order_trans)
+qed
+(*  by standard
+    (auto simp add: less_eq_bot_def less_bot_def less_le_not_le elim: order_trans split: bot.splits)*)
 
 end
 
 instance bot :: (order) order
-  by standard (auto simp add: less_eq_bot_def less_bot_def split: bot.splits)
+proof standard
+  fix x y :: "'a bot"
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y"
+    by (cases x; cases y; simp)
+qed
+(*  by standard (auto simp add: less_eq_bot_def less_bot_def split: bot.splits)*)
 
 instance bot :: (linorder) linorder
-  by standard (auto simp add: less_eq_bot_def less_bot_def split: bot.splits)
+proof standard
+  fix x y :: "'a bot"
+  show "x \<le> y \<or> y \<le> x"
+    by (cases x; cases y; simp add: linear)
+qed
+(*  by standard (auto simp add: less_eq_bot_def less_bot_def split: bot.splits)*)
 
 instantiation bot :: (order) bot
 begin
@@ -88,7 +109,17 @@
         | Value v' \<Rightarrow> Value (inf v v')))"
 
 instance
-  by standard (auto simp add: inf_bot_def less_eq_bot_def split: bot.splits)
+proof standard
+  fix x y :: "'a bot"
+  show "inf x y \<le> x"
+    by (cases x; cases y; simp add: inf_bot_def)
+  show "inf x y \<le> y"
+    by (cases x; cases y; simp add: inf_bot_def)
+  fix z :: "'a bot"
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> inf y z"
+    by (cases x; cases y; cases z; simp add: inf_bot_def)
+qed
+(*  by standard (auto simp add: inf_bot_def less_eq_bot_def split: bot.splits)*)
 
 end
 
@@ -106,7 +137,17 @@
         | Value v' \<Rightarrow> Value (sup v v')))"
 
 instance
-  by standard (auto simp add: sup_bot_def less_eq_bot_def split: bot.splits)
+proof standard
+  fix x y :: "'a bot"
+  show "x \<le> sup x y"
+    by (cases x; cases y; simp add: sup_bot_def)
+  show "y \<le> sup x y"
+    by (cases x; cases y; simp add: sup_bot_def)
+  fix z :: "'a bot"
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> sup y z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_bot_def)
+qed
+(*  by standard (auto simp add: sup_bot_def less_eq_bot_def split: bot.splits)*)
 
 end
 
@@ -158,16 +199,37 @@
   by (simp add: less_top_def)
 
 instance
-  by standard
-    (auto simp add: less_eq_top_def less_top_def less_le_not_le elim: order_trans split: top.splits)
+proof standard
+  fix x :: "'a top"
+  show "x \<le> x"
+    by (cases x; simp)
+  fix y :: "'a top"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)" 
+    by (cases x; cases y; simp add: less_le_not_le)
+  fix z :: "'a top" 
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z"
+    by (cases x; cases y; cases z; auto elim: order_trans)
+qed
+(*  by standard
+    (auto simp add: less_eq_top_def less_top_def less_le_not_le elim: order_trans split: top.splits)*)
 
 end
 
 instance top :: (order) order
-  by standard (auto simp add: less_eq_top_def less_top_def split: top.splits)
+proof standard
+  fix x y :: "'a top"
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y"
+    by (cases x; cases y; simp)
+qed
+(*  by standard (auto simp add: less_eq_top_def less_top_def split: top.splits)*)
 
 instance top :: (linorder) linorder
-  by standard (auto simp add: less_eq_top_def less_top_def split: top.splits)
+proof standard
+  fix x y :: "'a top"
+  show "x \<le> y \<or> y \<le> x"
+    by (cases x; cases y; simp add: linear)
+qed
+(*  by standard (auto simp add: less_eq_top_def less_top_def split: top.splits)*)
 
 instantiation top :: (order) top
 begin
@@ -195,7 +257,17 @@
         | Value v' \<Rightarrow> Value (inf v v')))"
 
 instance
-  by standard (auto simp add: inf_top_def less_eq_top_def split: top.splits)
+proof standard
+  fix x y :: "'a top"
+  show "inf x y \<le> x"
+    by (cases x; cases y; simp add: inf_top_def)
+  show "inf x y \<le> y"
+    by (cases x; cases y; simp add: inf_top_def)
+  fix z :: "'a top"
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> inf y z"
+    by (cases x; cases y; cases z; simp add: inf_top_def)
+qed
+(*  by standard (auto simp add: inf_top_def less_eq_top_def split: top.splits)*)
 
 end
 
@@ -213,7 +285,17 @@
         | Value v' \<Rightarrow> Value (sup v v')))"
 
 instance
-  by standard (auto simp add: sup_top_def less_eq_top_def split: top.splits)
+proof standard
+  fix x y :: "'a top"
+  show "x \<le> sup x y"
+    by (cases x; cases y; simp add: sup_top_def)
+  show "y \<le> sup x y"
+    by (cases x; cases y; simp add: sup_top_def)
+  fix z :: "'a top"
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> sup y z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_top_def)
+qed
+(*  by standard (auto simp add: sup_top_def less_eq_top_def split: top.splits)*)
 
 end
 
@@ -267,9 +349,22 @@
   by (cases z) (auto simp add: less_eq_flat_complete_lattice_def)
 
 instance
-  by standard
+proof standard
+  fix x :: "'a flat_complete_lattice"
+  show "x \<le> x"
+    by (cases x; simp add: less_eq_flat_complete_lattice_def)
+  fix y :: "'a flat_complete_lattice"
+  show "(x < y) = (x \<le> y \<and> \<not> y \<le> x)"
+    by (cases x; cases y; simp add: less_eq_flat_complete_lattice_def less_flat_complete_lattice_def)
+  show "x \<le> y \<Longrightarrow> y \<le> x \<Longrightarrow> x = y"
+    by (cases x; cases y; simp add: less_eq_flat_complete_lattice_def)
+  fix z :: "'a flat_complete_lattice"
+  show "x \<le> y \<Longrightarrow> y \<le> z \<Longrightarrow> x \<le> z"
+    by (cases x; cases y; cases z; simp add: less_eq_flat_complete_lattice_def)
+qed
+(*  by standard
     (auto simp add: less_eq_flat_complete_lattice_def less_flat_complete_lattice_def
-      split: flat_complete_lattice.splits)
+      split: flat_complete_lattice.splits)*)
 
 end
 
@@ -313,9 +408,25 @@
     | Top \<Rightarrow> Top)"
 
 instance
-  by standard
+proof standard
+  fix x y :: "'a flat_complete_lattice"
+  show "inf x y \<le> x"
+    by (cases x; cases y; simp add: inf_flat_complete_lattice_def less_eq_flat_complete_lattice_def)
+  show "inf x y \<le> y"
+    by (cases x; cases y; simp add: inf_flat_complete_lattice_def less_eq_flat_complete_lattice_def)
+  show "x \<le> sup x y"
+    by (cases x; cases y; simp add: sup_flat_complete_lattice_def less_eq_flat_complete_lattice_def)
+  show "y \<le> sup x y"
+    by (cases x; cases y; simp add: sup_flat_complete_lattice_def less_eq_flat_complete_lattice_def)
+  fix z :: "'a flat_complete_lattice"
+  show "x \<le> y \<Longrightarrow> x \<le> z \<Longrightarrow> x \<le> inf y z"
+    by (cases x; cases y; cases z; simp add: inf_flat_complete_lattice_def less_eq_flat_complete_lattice_def)
+  show "y \<le> x \<Longrightarrow> z \<le> x \<Longrightarrow> sup y z \<le> x"
+    by (cases x; cases y; cases z; simp add: sup_flat_complete_lattice_def less_eq_flat_complete_lattice_def)
+qed
+(*  by standard
     (auto simp add: inf_flat_complete_lattice_def sup_flat_complete_lattice_def
-      less_eq_flat_complete_lattice_def split: flat_complete_lattice.splits)
+      less_eq_flat_complete_lattice_def split: flat_complete_lattice.splits)*)
 
 end
 
diff -urNx '*~' ./Library/Mapping.thy /Applications/Isabelle2022.app/src/HOL/Library/Mapping.thy
--- ./Library/Mapping.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Mapping.thy	2023-07-04 17:01:45.000000000 +0900
@@ -959,8 +959,10 @@
     \<lbrakk> finite (keys m); k \<notin> keys m; (\<And>k'. k' \<in> keys m \<Longrightarrow> k' \<le> k); P m \<rbrakk>
     \<Longrightarrow> P (update k v m)"
   shows "P m"
-  using assms by transfer (simp add: linorder_finite_Map_induct)
-
+  using assms 
+  apply transfer
+  apply (rule linorder_finite_Map_induct; assumption?)
+  by blast
 
 subsection \<open>Code generator setup\<close>
 
diff -urNx '*~' ./Library/Multiset.thy /Applications/Isabelle2022.app/src/HOL/Library/Multiset.thy
--- ./Library/Multiset.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Multiset.thy	2023-07-03 09:56:18.000000000 +0900
@@ -3739,7 +3739,7 @@
 lemma mset_le_asym: "M < N \<Longrightarrow> (\<not> P \<Longrightarrow> N < (M::'a::preorder multiset)) \<Longrightarrow> P"
   by (fact less_asym)
 
-declaration \<open>
+(*declaration \<open>
   let
     fun multiset_postproc _ maybe_name all_values (T as Type (_, [elem_T])) (Const _ $ t') =
           let
@@ -3759,7 +3759,7 @@
           end
       | multiset_postproc _ _ _ _ t = t
   in Nitpick_Model.register_term_postprocessor \<^typ>\<open>'a multiset\<close> multiset_postproc end
-\<close>
+\<close>*)
 
 
 subsection \<open>Naive implementation using lists\<close>
@@ -3924,7 +3924,7 @@
 
 end
 
-instantiation multiset :: (random) random
+(*instantiation multiset :: (random) random
 begin
 
 context
@@ -3938,9 +3938,9 @@
 
 end
 
-end
+end*)
 
-instantiation multiset :: (full_exhaustive) full_exhaustive
+(*instantiation multiset :: (full_exhaustive) full_exhaustive
 begin
 
 definition full_exhaustive_multiset :: "('a multiset \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
@@ -3949,7 +3949,7 @@
 
 instance ..
 
-end
+end*)
 
 hide_const (open) msetify
 
diff -urNx '*~' ./Library/Poly_Mapping.thy /Applications/Isabelle2022.app/src/HOL/Library/Poly_Mapping.thy
--- ./Library/Poly_Mapping.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Poly_Mapping.thy	2023-07-04 17:54:40.000000000 +0900
@@ -552,7 +552,15 @@
       also have "\<dots> = (\<Sum>(a, bc, b, c). f a * g b * h c when bc = b + c when k = a + bc)"
       proof -
         have "bij (\<lambda>(a, d, b, c). (d, c, a, b))"
-          by (auto intro!: bijI injI surjI [of _ "\<lambda>(d, c, a, b). (a, d, b, c)"] simp add: split_def)
+        proof (intro bijI injI surjI [of _ "\<lambda>(d, c, a, b). (a, d, b, c)"])
+          fix x
+          show "(case case x of (d, c, a, b) \<Rightarrow> (a, d, b, c) of (a, d, b, c) \<Rightarrow> (d, c, a, b)) =  x"
+            by (cases x;simp)
+          fix y 
+          show "(case x of (a, d, b, c) \<Rightarrow> (d, c, a, b)) = (case y of (a, d, b, c) \<Rightarrow> (d, c, a, b)) \<Longrightarrow> x = y"
+            by (cases x; cases y; simp)
+        qed
+          (*by (auto intro!: bijI injI surjI [of _ "\<lambda>(d, c, a, b). (a, d, b, c)"] simp add: split_def)*)
         then show ?thesis
           by (rule Sum_any.reindex_cong) auto
       qed
diff -urNx '*~' ./Library/Predicate_Compile_Alternative_Defs.thy /Applications/Isabelle2022.app/src/HOL/Library/Predicate_Compile_Alternative_Defs.thy
--- ./Library/Predicate_Compile_Alternative_Defs.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Predicate_Compile_Alternative_Defs.thy	2023-07-12 19:07:40.000000000 +0900
@@ -205,7 +205,7 @@
 lemma list_all2_ConsI [code_pred_intro]: "list_all2 P xs ys ==> P x y ==> list_all2 P (x#xs) (y#ys)"
 by auto
 
-code_pred [skip_proof] list_all2
+code_pred list_all2
 proof -
   case list_all2
   from this show thesis
diff -urNx '*~' ./Library/Predicate_Compile_Quickcheck.thy /Applications/Isabelle2022.app/src/HOL/Library/Predicate_Compile_Quickcheck.thy
--- ./Library/Predicate_Compile_Quickcheck.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Predicate_Compile_Quickcheck.thy	2023-07-07 14:13:57.000000000 +0900
@@ -8,6 +8,6 @@
   imports Predicate_Compile_Alternative_Defs
 begin
 
-ML_file \<open>../Tools/Predicate_Compile/predicate_compile_quickcheck.ML\<close>
+(*ML_file \<open>../Tools/Predicate_Compile/predicate_compile_quickcheck.ML\<close>*)
 
 end
diff -urNx '*~' ./Library/Uprod.thy /Applications/Isabelle2022.app/src/HOL/Library/Uprod.thy
--- ./Library/Uprod.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Uprod.thy	2023-07-11 09:43:17.000000000 +0900
@@ -152,7 +152,7 @@
 instance by standard(simp add: equal_uprod_def)
 end
 
-quickcheck_generator uprod constructors: Upair
+(*quickcheck_generator uprod constructors: Upair*)
 
 lemma UNIV_uprod: "UNIV = (\<lambda>x. Upair x x) ` UNIV \<union> (\<lambda>(x, y). Upair x y) ` Sigma UNIV (\<lambda>x. UNIV - {x})"
 apply(rule set_eqI)
diff -urNx '*~' ./Library/Word.thy /Applications/Isabelle2022.app/src/HOL/Library/Word.thy
--- ./Library/Word.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Library/Word.thy	2023-07-07 14:03:56.000000000 +0900
@@ -57,7 +57,31 @@
   by (auto simp add: take_bit_eq_mod intro: mod_mult_cong)
 
 instance
-  by (standard; transfer) (simp_all add: algebra_simps)
+proof (standard)
+  show "(0 :: 'a word) \<noteq> 1"
+    by (transfer;simp)
+  fix a :: "'a word"
+  show "1 * a = a"
+    by (transfer;simp)
+  show "0 + a = a"
+    by (transfer;simp)
+  show "- a + a = 0"
+    by (transfer;simp)
+  fix b :: "'a word"
+  show "a * b = b * a"
+    by (transfer;simp add: ac_simps)
+  show "a + b = b + a"
+    by (transfer;simp add: ac_simps)
+  show "a - b = a + - b"
+    by (transfer;simp)
+  fix c :: "'a word"
+  show "a * b * c = a * (b * c)"
+    by (transfer;simp add: ac_simps)
+  show "a + b + c = a + (b + c)"
+    by (transfer;simp add: ac_simps)
+  show "(a + b) * c = a * c + b * c"
+    by (transfer;simp add: distrib_right)
+qed
 
 end
 
@@ -150,10 +174,10 @@
   \<open>Word.Word = of_int\<close>
   by (rule; transfer) simp
 
-quickcheck_generator word
+(*quickcheck_generator word
   constructors:
     \<open>0 :: 'a::len word\<close>,
-    \<open>numeral :: num \<Rightarrow> 'a::len word\<close>
+    \<open>numeral :: num \<Rightarrow> 'a::len word\<close>*)
 
 instantiation word :: (len) equal
 begin
@@ -987,7 +1011,8 @@
   is \<open>\<lambda>n. take_bit (min LENGTH('a) n)\<close>
   by (simp add: ac_simps) (simp only: flip: take_bit_take_bit)
 
-instance apply (standard; transfer)
+instance 
+  apply (standard; transfer)
   apply (auto simp add: minus_eq_not_minus_1 mask_eq_exp_minus_1
     bit_simps set_bit_def flip_bit_def take_bit_drop_bit
     simp flip: drop_bit_eq_div take_bit_eq_mod)
@@ -1290,7 +1315,7 @@
     by simp
   case False
   then show ?thesis
-    by transfer (auto simp add: signed_take_bit_eq intro: order_trans *)
+    by transfer (auto simp add: signed_take_bit_eq intro: order_trans * )
 qed
 
 lemma sint_less:
@@ -1668,11 +1693,11 @@
     by simp
   have \<open>a = 0\<close> if \<open>2 * a = 0\<close> and \<open>a \<noteq> 2 ^ (LENGTH('a) - Suc 0)\<close>
     using that by transfer
-      (auto simp add: take_bit_eq_0_iff take_bit_eq_mod *)
+      (auto simp add: take_bit_eq_0_iff take_bit_eq_mod * )
   moreover have \<open>2 ^ LENGTH('a) = (0 :: 'a word)\<close>
     by transfer simp
   then have \<open>2 * 2 ^ (LENGTH('a) - Suc 0) = (0 :: 'a word)\<close>
-    by (simp add: *)
+    by (simp add: * )
   ultimately show ?thesis
     by auto
 qed
@@ -1849,14 +1874,22 @@
   case (Suc n)
   from Suc.prems have \<open>take_bit n (k div 2) = take_bit n (l div 2)\<close>
     by (simp add: take_bit_Suc)
-  then have \<open>map (bit (k div 2)) [0..<n] = map (bit (l div 2)) [0..<n]\<close>
-    by (rule Suc.IH)
-  moreover have \<open>bit (r div 2) = bit r \<circ> Suc\<close> for r :: int
+  then have *: \<open>map (bit (k div 2)) [0..<n] = map (bit (l div 2)) [0..<n]\<close>
+ by (rule Suc.IH)
+  have \<open>bit (r div 2) = bit r \<circ> Suc\<close> for r :: int
     by (simp add: fun_eq_iff bit_Suc)
-  moreover from Suc.prems have \<open>even k \<longleftrightarrow> even l\<close>
-    by (auto simp add: take_bit_Suc elim!: evenE oddE) arith+
+  with * have \<open>map (bit k \<circ> Suc) [0..<n] = map (bit l \<circ> Suc) [0..<n]\<close>
+    by simp
+  moreover from Suc.prems have \<open>odd k \<longleftrightarrow> odd l\<close>
+    apply (simp only: take_bit_Suc)
+    by arith
   ultimately show ?case
-    by (simp only: map_Suc_upt upt_conv_Cons flip: list.map_comp) (simp add: bit_0)
+    apply (simp only: upt_conv_Cons[of 0 "Suc n"])
+    apply (simp only: list.map(2)[of "bit k" 0 "[Suc 0..<Suc n]"] list.map(2)[of "bit l" 0 "[Suc 0..<Suc n]"])
+    apply (simp only: list.inject[of "bit k 0" "map (bit k) [Suc 0..<Suc n]" "bit l 0" "map (bit l) [Suc 0..<Suc n]"])
+    apply (intro conjI)
+     apply (simp only: flip: bit_0[of k] bit_0[of l])
+    by (simp only: map_Suc_upt[of 0 n] flip: list.map_comp[of "bit l" Suc "[0..<n]"] list.map_comp[of "bit k" Suc "[0..<n]"])
 qed
 
 lemma
@@ -2975,10 +3008,53 @@
     (if unat a + unat b < 2 ^ LENGTH('a)
     then unat a + unat b
     else unat a + unat b - 2 ^ LENGTH('a))\<close> for a b :: \<open>'a::len word\<close>
-  apply (auto simp add: not_less le_iff_add)
-   apply (metis (mono_tags, lifting) of_nat_add of_nat_unat take_bit_nat_eq_self_iff unsigned_less unsigned_of_nat unsigned_word_eqI)
-  apply (smt (verit, ccfv_SIG) dbl_simps(3) dbl_simps(5) numerals(1) of_nat_0_le_iff of_nat_add of_nat_eq_iff of_nat_numeral of_nat_power of_nat_unat uint_plus_if' unsigned_1)
-  done
+proof (transfer; simp add: not_less le_iff_add, intro conjI impI)
+  fix a b assume bound: "nat (take_bit LENGTH('a) a) + nat (take_bit  LENGTH('a) b)  < 2 ^ LENGTH('a)"
+  note eq_nat_nat_iff[OF take_bit_nonnegative[of "LENGTH('a)" _] take_bit_nonnegative[of "LENGTH('a)" _], THEN iffD2, OF 
+      take_bit_add[of "LENGTH('a)" a b]]
+  with take_bit_nat_eq[of _ "LENGTH('a)"] take_bit_nonnegative[of "LENGTH('a)" _]
+  have "take_bit LENGTH('a) (nat (take_bit LENGTH('a) a + take_bit LENGTH('a) b)) = nat (take_bit LENGTH('a) (a + b))"
+    by simp
+  with nat_add_distrib take_bit_nonnegative[of "LENGTH('a)" _]
+  have "take_bit LENGTH('a) (nat (take_bit LENGTH('a) a) + nat (take_bit LENGTH('a) b)) = ..."
+    by simp
+  with take_bit_nat_eq_self_iff[THEN iffD2, OF bound]
+  show "nat (take_bit LENGTH('a) (a + b)) = nat (take_bit LENGTH('a) a) + nat (take_bit LENGTH('a) b)"
+    by simp
+next
+  fix a b assume "\<exists>c. nat (take_bit LENGTH('a) a) + nat (take_bit LENGTH('a)  b) = 2 ^ LENGTH('a) + c"
+  then obtain c where c: "nat (take_bit LENGTH('a) a) + nat (take_bit LENGTH('a)  b) = 2 ^ LENGTH('a) + c" by auto
+  note eq_nat_nat_iff[OF take_bit_nonnegative[of "LENGTH('a)" _] take_bit_nonnegative[of "LENGTH('a)" _], THEN iffD2, OF 
+      take_bit_add[of "LENGTH('a)" a b]]
+  with take_bit_nat_eq[of _ "LENGTH('a)"] take_bit_nonnegative[of "LENGTH('a)" _]
+  have "take_bit LENGTH('a) (nat (take_bit LENGTH('a) a + take_bit LENGTH('a) b)) = nat (take_bit LENGTH('a) (a + b))"
+    by simp
+  with nat_add_distrib take_bit_nonnegative[of "LENGTH('a)" _]
+  have "take_bit LENGTH('a) (nat (take_bit LENGTH('a) a) + nat (take_bit LENGTH('a) b)) = ..."
+    by simp
+  with c 
+  have "take_bit LENGTH('a) (2 ^ LENGTH('a) + c) = ..."
+    by simp
+  with take_bit_add[of "LENGTH('a)" "2 ^ LENGTH('a)" "c"]
+  have *: "take_bit LENGTH('a) ((take_bit LENGTH('a) (2 ^ LENGTH('a))) + (take_bit LENGTH('a) c)) = ..."
+    by presburger
+  with take_bit_of_exp[of "LENGTH('a)" "LENGTH('a)"]
+  have "take_bit LENGTH('a) (2 ^ LENGTH('a)) = 0"
+    by (smt (verit) mult_zero_left of_bool_eq(1) of_nat_0 of_nat_numeral of_nat_power order_less_irrefl take_bit_of_nat)
+  with * have "take_bit LENGTH('a) (take_bit LENGTH('a) c) = nat (take_bit LENGTH('a) (a + b))"
+    by (smt (verit, best) add_0)
+  with take_bit_take_bit[of "LENGTH('a)" "LENGTH('a)" c]
+  have **: "take_bit LENGTH('a) c = ..."
+    by simp
+  with take_bit_int_less_exp[of "LENGTH('a)" a] take_bit_int_less_exp[of "LENGTH('a)" b] c
+  have "c < 2 ^ LENGTH('a)"
+    by (metis add_less_cancel_left add_mono_thms_linordered_field(5) id_apply of_nat_eq_id unsigned_less unsigned_of_int)
+  from take_bit_nat_eq_self_iff[THEN iffD2, OF this] **
+  have "c = nat (take_bit LENGTH('a) (a + b))"
+    by simp
+  with c show "nat (take_bit LENGTH('a) (a + b)) = nat (take_bit LENGTH('a) a) + nat (take_bit  LENGTH('a) b) - 2 ^ LENGTH('a)"
+    by simp
+qed
 
 lemma unat_sub_if_size:
   "unat (x - y) =
@@ -3991,9 +4067,95 @@
   from that have **: \<open>LENGTH('b) = n + k - LENGTH('a)\<close>
     by simp
   show \<open>bit (slice1 n (word_reverse w :: 'b word) :: 'a word) m \<longleftrightarrow> bit (word_reverse (slice1 k w :: 'a word)) m\<close>
-    unfolding bit_slice1_iff bit_word_reverse_iff
-    using * **
-    by (cases \<open>n \<le> LENGTH('a)\<close>; cases \<open>k \<le> LENGTH('a)\<close>) auto
+  proof (cases \<open>n < LENGTH('b)\<close>; cases \<open>k < LENGTH('b)\<close>)
+    assume nlb: "n < LENGTH('b)" and klb: "k < LENGTH('b)"
+    with that have nlea: "LENGTH('a) \<le> n" and klea: "LENGTH('a) \<le> k"
+      by auto
+    with * have mla: "m  < n" and mlb: "m < k"
+      by auto
+    from nlb nlea *
+    have "True = (n - LENGTH('b) \<le> m \<and>  m < min LENGTH('a) n \<and> m + (LENGTH('b) - n) - (n - LENGTH('b)) < LENGTH('b))"
+      by auto 
+    with klb klea *
+    have 1: "(m < LENGTH('a) \<and> k - LENGTH('b) \<le> LENGTH('a) -  Suc m \<and> LENGTH('a) - Suc m < min LENGTH('a) k) = ..."
+      by auto
+    from that klb
+    have "n - Suc m = (LENGTH('a) - Suc m + (LENGTH('b) - k) - (k - LENGTH('b)))"
+      by (simp add: "*" Suc_leI)
+    with nlb
+    have 2: "(LENGTH('b) - Suc (m + (LENGTH('b) - n) - (n - LENGTH('b)))) = ..."
+      by auto
+    show ?thesis
+      apply (unfold bit_slice1_iff bit_word_reverse_iff)
+      using 1 2
+      by metis
+  next
+    assume nlb: "n < LENGTH('b)" and nklb: "\<not> k < LENGTH('b)"
+    then have kleb: "LENGTH('b) \<le> k" by auto
+    with nlb that have alk: "LENGTH('a) < k" and mlea: "n \<le> LENGTH('a)"
+      by auto
+    with * have mlk: "m < k" by auto
+    with * nlb
+    have "(m < n) = (n - LENGTH('b) \<le> m \<and>  m < min LENGTH('a) n \<and> m + (LENGTH('b) - n) - (n - LENGTH('b)) < LENGTH('b))"
+      by auto
+    with * that alk
+    have 1: "(m < LENGTH('a) \<and> k - LENGTH('b) \<le> LENGTH('a) -  Suc m \<and> LENGTH('a) - Suc m < min LENGTH('a) k) = ..."
+      by auto
+    from kleb * that
+    have "n - Suc m = (LENGTH('a) - Suc m + (LENGTH('b) - k) - (k - LENGTH('b)))"
+      by auto
+    with nlb 
+    have 2: "(LENGTH('b) - Suc (m + (LENGTH('b) - n) - (n - LENGTH('b)))) = ..."
+      by auto
+    show ?thesis
+      apply (unfold bit_slice1_iff bit_word_reverse_iff)
+      using 1 2
+      by metis
+  next
+    assume nnlb: "\<not> n < LENGTH('b)" and klb: "k < LENGTH('b)"
+    then have nleb: "LENGTH('b) \<le> n" by auto
+    with klb that have klea: "k \<le> LENGTH('a)" and aln: "LENGTH('a) < n"
+      by auto
+    with * have mln: "m < n" by auto
+    from * mln
+    have "(n - LENGTH('b) \<le> m) = (n - LENGTH('b) \<le> m \<and>  m < min LENGTH('a) n \<and> m + (LENGTH('b) - n) - (n - LENGTH('b)) < LENGTH('b))"
+      by auto
+    with * klb that
+    have 1: "(m < LENGTH('a) \<and> k - LENGTH('b) \<le> LENGTH('a) -  Suc m \<and> LENGTH('a) - Suc m < min LENGTH('a) k) = ..."
+      by (simp add: "**" add.commute le_diff_conv less_Suc_eq_le less_diff_conv2)
+    from that klb *
+    have "n - Suc m = (LENGTH('a) - Suc m + (LENGTH('b) - k) - (k - LENGTH('b)))"
+      by auto
+    with nleb 
+    have 2: "(n - LENGTH('b) \<le> m) \<Longrightarrow> (LENGTH('b) - Suc (m + (LENGTH('b) - n) - (n - LENGTH('b)))) = ..."
+      by (metis add.right_neutral diff_Suc_diff_eq1 diff_is_0_eq' le_add_diff_inverse)
+    show ?thesis
+      apply (unfold bit_slice1_iff bit_word_reverse_iff)
+      using 1 2
+      by metis
+  next
+    assume nnlb: "\<not> n < LENGTH('b)" and nklb: "\<not> k < LENGTH('b)"
+    then have blen: "LENGTH('b) \<le> n" and blek: "LENGTH('b) \<le> k"
+      by auto
+    with that have klea: "k \<le> LENGTH('a)" and nlea: "n \<le> LENGTH('a)"
+      by auto
+    from * blen
+    have "(n - LENGTH('b) \<le> m \<and> m < n) = (n - LENGTH('b) \<le> m \<and>  m < min LENGTH('a) n \<and> m + (LENGTH('b) - n) - (n - LENGTH('b)) < LENGTH('b))"
+      by auto
+    with * that blek
+    have 1: "(m < LENGTH('a) \<and> k - LENGTH('b) \<le> LENGTH('a) -  Suc m \<and> LENGTH('a) - Suc m < min LENGTH('a) k) = ..."
+      by (smt (verit, ccfv_SIG) Nat.diff_cancel Nat.le_diff_conv2 Suc_leI add.commute add_le_imp_le_diff klea le_add_diff_inverse2 le_imp_less_Suc less_Suc_eq_le less_diff_conv2 less_eq_Suc_le min.absorb2 nat_add_left_cancel_le)
+    from that blek
+    have "m < n \<Longrightarrow> n - Suc m = (LENGTH('a) - Suc m + (LENGTH('b) - k) - (k - LENGTH('b)))"
+      by auto
+    with blen nlea that
+    have 2: "(n - LENGTH('b) \<le> m) \<Longrightarrow> (LENGTH('b) - Suc (m + (LENGTH('b) - n) - (n - LENGTH('b)))) = ..."
+      by simp
+    show ?thesis
+      apply (unfold bit_slice1_iff bit_word_reverse_iff)
+      using 1 2
+      by metis
+  qed
 qed
 
 lemma rev_slice:
@@ -4484,12 +4646,11 @@
     by (metis (no_types, lifting) \<section> diff_add_cancel minus_diff_eq uminus_add_conv_diff word_rec_id_eq)
   finally show ?thesis .
 qed
-
 end
 
-
 subsection \<open>Tool support\<close>
 
 ML_file \<open>Tools/smt_word.ML\<close>
 
+
 end
diff -urNx '*~' ./List.thy /Applications/Isabelle2022.app/src/HOL/List.thy
--- ./List.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/List.thy	2023-06-05 09:48:57.000000000 +0900
@@ -5,7 +5,7 @@
 section \<open>The datatype of finite lists\<close>
 
 theory List
-imports Sledgehammer Lifting_Set
+imports Lifting_Set Set_Interval Numeral_Simprocs
 begin
 
 datatype (set: 'a) list =
@@ -962,13 +962,13 @@
 by (induct xs) auto
 
 lemma hd_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> hd (xs @ ys) = hd xs"
-by (simp add: hd_append split: list.split)
+by (simp add: hd_append)
 
 lemma tl_append: "tl (xs @ ys) = (case xs of [] \<Rightarrow> tl ys | z#zs \<Rightarrow> zs @ ys)"
-by (simp split: list.split)
+by (cases xs; simp)
 
 lemma tl_append2 [simp]: "xs \<noteq> [] \<Longrightarrow> tl (xs @ ys) = tl xs @ ys"
-by (simp add: tl_append split: list.split)
+by (cases xs;simp add: tl_append)
 
 lemma tl_append_if: "tl (xs @ ys) = (if xs = [] then tl ys else tl xs @ ys)"
 by (simp)
@@ -1591,7 +1591,7 @@
   proof (cases)
     assume "p x"
     hence eq: "?S' = insert 0 (Suc ` ?S)"
-      by(auto simp: image_def split:nat.split dest:gr0_implies_Suc)
+      by (auto simp: image_def dest:gr0_implies_Suc)
     have "length (filter p (x # xs)) = Suc(card ?S)"
       using Cons \<open>p x\<close> by simp
     also have "\<dots> = Suc(card(Suc ` ?S))" using fin
@@ -2440,7 +2440,7 @@
   by (induct xs) (auto split: if_split_asm)
 
 lemma set_takeWhileD: "x \<in> set (takeWhile P xs) \<Longrightarrow> x \<in> set xs \<and> P x"
-  by (induct xs) (auto split: if_split_asm)
+  by (induct xs) auto 
 
 lemma takeWhile_eq_all_conv[simp]:
   "(takeWhile P xs = xs) = (\<forall>x \<in> set xs. P x)"
@@ -2596,7 +2596,7 @@
 
 lemma zip_Cons1:
   "zip (x#xs) ys = (case ys of [] \<Rightarrow> [] | y#ys \<Rightarrow> (x,y)#zip xs ys)"
-  by(auto split:list.split)
+  by (cases xs; cases ys; simp)
 
 lemma length_zip [simp]:
   "length (zip xs ys) = min (length xs) (length ys)"
@@ -4462,9 +4462,10 @@
   distinct (removeAll [] xs) \<and>
   (\<forall>ys. ys \<in> set xs \<longrightarrow> distinct ys) \<and>
   (\<forall>ys zs. ys \<in> set xs \<and> zs \<in> set xs \<and> ys \<noteq> zs \<longrightarrow> set ys \<inter> set zs = {})"
-apply (induct xs)
- apply(simp_all, safe, auto)
-by (metis Int_iff UN_I empty_iff equals0I set_empty)
+proof(induct xs)
+  case (Cons a xs)
+  show ?case by (auto simp: Cons Ball_def disjnt_def[symmetric] disjnt_sym)
+qed simp
 
 
 subsubsection \<open>\<^const>\<open>replicate\<close>\<close>
@@ -5050,7 +5051,10 @@
   "z # zs \<in> shuffles xs ys \<longleftrightarrow>
     (xs \<noteq> [] \<and> hd xs = z \<and> zs \<in> shuffles (tl xs) ys \<or>
      ys \<noteq> [] \<and> hd ys = z \<and> zs \<in> shuffles xs (tl ys))"
-  by (induct xs ys rule: shuffles.induct) auto
+proof(induct xs ys rule: shuffles.induct)
+  case (3 x xs y ys)
+  show ?case by (auto simp: 3)
+qed auto
 
 lemma splice_in_shuffles [simp, intro]: "splice xs ys \<in> shuffles xs ys"
   by (induction xs ys rule: splice.induct) (simp_all add: Cons_in_shuffles_iff shuffles_commutes)
@@ -5197,13 +5201,12 @@
   (is "max _ ?foldB = Suc (max _ ?foldA)")
 proof (cases "(filter (\<lambda>ys. ys \<noteq> []) xss) = []")
   case True
-  hence "foldr (\<lambda>xs. max (length xs)) xss 0 = 0"
+  then show ?thesis 
   proof (induct xss)
-    case (Cons x xs)
-    then have "x = []" by (cases x) auto
-    with Cons show ?case by auto
+    case (Cons a xsss)
+    then show ?case 
+      by (cases a; simp add: filter_def)
   qed simp
-  thus ?thesis using True by simp
 next
   case False
 
@@ -6363,7 +6366,7 @@
 
 lemma sorted_list_of_set_lessThan_Suc [simp]:
   "sorted_list_of_set {..<Suc k} = sorted_list_of_set {..<k} @ [k]"
-  using le0 lessThan_atLeast0 sorted_list_of_set_range upt_Suc_append by presburger
+  using lessThan_atLeast0 by auto
 
 lemma sorted_list_of_set_atMost_Suc [simp]:
   "sorted_list_of_set {..Suc k} = sorted_list_of_set {..k} @ [Suc k]"
@@ -6835,7 +6838,7 @@
     by blast
   hence "((u@v)!i, (w@z)!i) \<in> r"
     unfolding nth_append using less_le_trans[OF \<open>i < length w\<close> assms(2)] \<open>(u!i,w!i) \<in> r\<close>
-    by presburger
+    by auto
   moreover have "i < min (length (u@v)) (length (w@z))"
     using assms(2) \<open>i < length w\<close> by simp
   moreover have "take i (u@v) = take i (w@z)"
diff -urNx '*~' ./MacLaurin.thy /Applications/Isabelle2022.app/src/HOL/MacLaurin.thy
--- ./MacLaurin.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/MacLaurin.thy	2023-06-05 09:48:57.000000000 +0900
@@ -22,7 +22,7 @@
 
 lemma eq_diff_eq': "x = y - z \<longleftrightarrow> y = x + z"
   for x y z :: real
-  by arith
+  by (auto elim: iffE)
 
 lemma fact_diff_Suc: "n < Suc m \<Longrightarrow> fact (Suc m - n) = (Suc m - n) * fact (m - n)"
   by (subst fact_reduce) auto
@@ -343,6 +343,9 @@
 lemma sin_expansion_lemma: "sin (x + real (Suc m) * pi / 2) = cos (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add add_divide_distrib distrib_right)
 
+lemma sin_coeff_lemma: "sin_coeff m * x ^ m  = sin (1 / 2 * real m * pi) / fact m * x ^ m"
+  by (cases "even m") (auto simp add: sin_zero_iff sin_coeff_def elim: oddE simp del: of_nat_Suc) 
+
 lemma Maclaurin_sin_expansion2:
   "\<exists>t. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     sin x = (\<Sum>m<n. sin_coeff m * x ^ m) + (sin (t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -350,17 +353,16 @@
   case False
   let ?diff = "\<lambda>n x. sin (x + 1/2 * real n * pi)"
   have "\<exists>t. 0 < \<bar>t\<bar> \<and> \<bar>t\<bar> < \<bar>x\<bar> \<and> sin x =
-      (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
+    (\<Sum>m<n. (?diff m 0 / fact m) * x ^ m) + (?diff n t / fact n) * x ^ n"
   proof (rule Maclaurin_all_lt)
     show "\<forall>m x. ((\<lambda>t. sin (t + 1/2 * real m * pi)) has_real_derivative
-           sin (x + 1/2 * real (Suc m) * pi)) (at x)"
+       sin (x + 1/2 * real (Suc m) * pi)) (at x)"
       by (rule allI derivative_eq_intros | use sin_expansion_lemma in force)+
   qed (use False in auto)
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed auto
 
 lemma Maclaurin_sin_expansion:
@@ -385,8 +387,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 lemma Maclaurin_sin_expansion4:
@@ -406,8 +407,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: sin_coeff_def sin_zero_iff elim: oddE simp del: of_nat_Suc)
-    done
+    by (simp add: sin_coeff_lemma)
 qed
 
 
@@ -419,6 +419,16 @@
 lemma cos_expansion_lemma: "cos (x + real (Suc m) * pi / 2) = - sin (x + real m * pi / 2)"
   by (auto simp: cos_add sin_add distrib_right add_divide_distrib)
 
+lemma cos_coeff_lemma: "cos_coeff m * x ^ m  = cos (1 / 2 * real m * pi) / fact m * x ^ m"
+proof(cases "odd m")
+  case t: True
+    then show ?thesis by (simp add: cos_coeff_def cos_zero_iff)
+ next
+  case False
+    then show ?thesis using False 
+      by (auto simp add: cos_coeff_def elim: oddE simp del: of_nat_Suc) 
+qed
+
 lemma Maclaurin_cos_expansion:
   "\<exists>t::real. \<bar>t\<bar> \<le> \<bar>x\<bar> \<and>
     cos x = (\<Sum>m<n. cos_coeff m * x ^ m) + (cos(t + 1/2 * real n * pi) / fact n) * x ^ n"
@@ -436,8 +446,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE simp del: of_nat_Suc)
-    done
+    by (simp add: cos_coeff_lemma)
 qed auto
 
 lemma Maclaurin_cos_expansion2:
@@ -456,8 +465,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 lemma Maclaurin_minus_cos_expansion:
@@ -476,8 +484,7 @@
   then show ?thesis
     apply (rule ex_forward, simp)
     apply (rule sum.cong[OF refl])
-    apply (auto simp: cos_coeff_def cos_zero_iff elim: evenE)
-    done
+    by (simp add: cos_coeff_lemma)
 qed
 
 
@@ -537,7 +544,7 @@
   shows "\<exists>t::real. c < t \<and> t < b \<and>
     f b = (\<Sum>m<n. (diff m c / fact m) * (b - c)^m) + (diff n t / fact n) * (b - c)^n"
 proof -
-  from INTERV have "0 < b - c" by arith
+  from INTERV have "0 < b - c" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -573,7 +580,7 @@
   shows "\<exists>t. a < t \<and> t < c \<and>
     f a = (\<Sum>m<n. (diff m c / fact m) * (a - c)^m) + (diff n t / fact n) * (a - c)^n"
 proof -
-  from INTERV have "a-c < 0" by arith
+  from INTERV have "a-c < 0" by simp
   moreover from INIT have "n > 0" "(\<lambda>m x. diff m (x + c)) 0 = (\<lambda>x. f (x + c))"
     by auto
   moreover
@@ -627,9 +634,9 @@
   moreover have "\<forall>m t. m < n \<and> a \<le> t \<and> t \<le> x \<longrightarrow> DERIV (diff m) t :> diff (Suc m) t"
     using DERIV and INTERV by fastforce
   moreover from INTERV have "a \<le> c"
-    by arith
+    by simp
   moreover from False and INTERV have "c < x"
-    by arith
+    by simp
   ultimately have "\<exists>t>c. t < x \<and> f x =
     (\<Sum>m<n. diff m c / (fact m) * (x - c) ^ m) + diff n t / (fact n) * (x - c) ^ n"
     by (rule Taylor_up)
diff -urNx '*~' ./Nitpick.thy /Applications/Isabelle2022.app/src/HOL/Nitpick.thy
--- ./Nitpick.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Nitpick.thy	2023-06-05 09:48:57.000000000 +0900
@@ -8,7 +8,7 @@
 section \<open>Nitpick: Yet Another Counterexample Generator for Isabelle/HOL\<close>
 
 theory Nitpick
-imports Record GCD
+imports Record GCD Sledgehammer
 keywords
   "nitpick" :: diag and
   "nitpick_params" :: thy_decl
diff -urNx '*~' ./Quickcheck_Exhaustive.thy /Applications/Isabelle2022.app/src/HOL/Quickcheck_Exhaustive.thy
--- ./Quickcheck_Exhaustive.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Quickcheck_Exhaustive.thy	2023-06-05 09:48:57.000000000 +0900
@@ -6,7 +6,7 @@
 
 theory Quickcheck_Exhaustive
 imports Quickcheck_Random
-keywords "quickcheck_generator" :: thy_decl
+(*keywords "quickcheck_generator" :: thy_decl*)
 begin
 
 subsection \<open>Basic operations for exhaustive generators\<close>
@@ -739,16 +739,16 @@
 axiomatization unknown :: 'a
 
 notation (output) unknown  ("?")
-
+(*
 ML_file \<open>Tools/Quickcheck/exhaustive_generators.ML\<close>
-
+*)
 declare [[quickcheck_batch_tester = exhaustive]]
 
 
 subsection \<open>Defining generators for abstract types\<close>
-
+(*
 ML_file \<open>Tools/Quickcheck/abstract_generators.ML\<close>
-
+*)
 hide_fact (open) orelse_def
 no_notation orelse  (infixr "orelse" 55)
 
diff -urNx '*~' ./Quickcheck_Narrowing.thy /Applications/Isabelle2022.app/src/HOL/Quickcheck_Narrowing.thy
--- ./Quickcheck_Narrowing.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Quickcheck_Narrowing.thy	2023-06-05 09:48:57.000000000 +0900
@@ -196,7 +196,9 @@
 
 external_file \<open>~~/src/HOL/Tools/Quickcheck/Narrowing_Engine.hs\<close>
 external_file \<open>~~/src/HOL/Tools/Quickcheck/PNF_Narrowing_Engine.hs\<close>
+(*
 ML_file \<open>Tools/Quickcheck/narrowing_generators.ML\<close>
+*)
 
 definition narrowing_dummy_partial_term_of :: "('a :: partial_term_of) itself => narrowing_term => term"
 where
@@ -206,6 +208,7 @@
 where
   "narrowing_dummy_narrowing = narrowing"
 
+(*
 lemma [code]:
   "ensure_testable f =
     (let
@@ -224,6 +227,7 @@
 instance ..
 
 end
+*)
   
 subsection \<open>Narrowing for integers\<close>
 
@@ -264,6 +268,7 @@
 
 end
 
+(*
 declare [[code drop: "partial_term_of :: int itself \<Rightarrow> _"]]
 
 lemma [code]:
@@ -274,6 +279,7 @@
      then Code_Evaluation.term_of (- (int_of_integer i) div 2)
      else Code_Evaluation.term_of ((int_of_integer i + 1) div 2))"
   by (rule partial_term_of_anything)+
+*)
 
 instantiation integer :: narrowing
 begin
@@ -286,6 +292,7 @@
 
 end
 
+(*
 declare [[code drop: "partial_term_of :: integer itself \<Rightarrow> _"]]  
 
 lemma [code]:
@@ -296,6 +303,7 @@
      then Code_Evaluation.term_of (- i div 2)
      else Code_Evaluation.term_of ((i + 1) div 2))"
   by (rule partial_term_of_anything)+
+*)
 
 code_printing constant "Code_Evaluation.term_of :: integer \<Rightarrow> term" \<rightharpoonup> (Haskell_Quickcheck) 
   "(let { t = Typerep.Typerep \"Code'_Numeral.integer\" [];
diff -urNx '*~' ./Quickcheck_Random.thy /Applications/Isabelle2022.app/src/HOL/Quickcheck_Random.thy
--- ./Quickcheck_Random.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Quickcheck_Random.thy	2023-06-05 09:48:57.000000000 +0900
@@ -213,6 +213,7 @@
 
 end
 
+(* Proof generation fails with this!
 instantiation set :: (random) random
 begin
 
@@ -220,35 +221,42 @@
   includes state_combinator_syntax
 begin
 
-fun random_aux_set
+fun random_aux_set :: "'a itself \<Rightarrow> natural
+     \<Rightarrow> natural
+        \<Rightarrow> natural \<times> natural
+           \<Rightarrow> ('a set \<times>
+(unit \<Rightarrow> term)) \<times>
+              natural \<times>
+              natural"
 where
-  "random_aux_set 0 j = collapse (Random.select_weight [(1, Pair valterm_emptyset)])"
-| "random_aux_set (Code_Numeral.Suc i) j =
+  "random_aux_set (x :: 'a itself) 0 j = collapse (Random.select_weight [(1, Pair valterm_emptyset)])"
+| "random_aux_set t (Code_Numeral.Suc i) j =
     collapse (Random.select_weight
       [(1, Pair valterm_emptyset),
        (Code_Numeral.Suc i,
-        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+        scomp (random j) (%x. scomp (random_aux_set t i j) (%s. Pair (valtermify_insert x s))))])"
 
 lemma [code]:
-  "random_aux_set i j =
+  "random_aux_set t i j =
     collapse (Random.select_weight [(1, Pair valterm_emptyset),
-      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+      (i, random j \<circ>\<rightarrow> (%x. random_aux_set t (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
 proof (induct i rule: natural.induct)
   case zero
   show ?case by (subst select_weight_drop_zero [symmetric])
     (simp add: random_aux_set.simps [simplified] less_natural_def)
 next
   case (Suc i)
-  show ?case by (simp only: random_aux_set.simps(2) [of "i"] Suc_natural_minus_one)
+  show ?case by (simp only: random_aux_set.simps(2) [of _ "i"] Suc_natural_minus_one)
 qed
 
-definition "random_set i = random_aux_set i i"
+definition "random_set i = random_aux_set TYPE('a) i i"
 
 instance ..
 
 end
 
 end
+*)
 
 lemma random_aux_rec:
   fixes random_aux :: "natural \<Rightarrow> 'a"
@@ -260,9 +268,9 @@
 subsection \<open>Deriving random generators for datatypes\<close>
 
 ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
+(*
 ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
-
-
+*)
 subsection \<open>Code setup\<close>
 
 code_printing
diff -urNx '*~' ./Random_Prep.thy /Applications/Isabelle2022.app/src/HOL/Random_Prep.thy
--- ./Random_Prep.thy	1970-01-01 09:00:00.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Random_Prep.thy	2023-06-05 09:48:57.000000000 +0900
@@ -0,0 +1,386 @@
+(*  Title:      HOL/Quickcheck_Random.thy
+    Author:     Florian Haftmann & Lukas Bulwahn, TU Muenchen
+*)
+
+section \<open>A simple counterexample generator performing random testing\<close>
+
+theory Random_Prep
+imports Random Code_Evaluation Enum
+begin
+
+(*setup \<open>Code_Target.add_derived_target ("Quickcheck", [(Code_Runtime.target, I)])\<close>*)
+
+(*subsection \<open>Catching Match exceptions\<close>
+
+axiomatization catch_match :: "'a => 'a => 'a"
+
+code_printing
+  constant catch_match \<rightharpoonup> (Quickcheck) "((_) handle Match => _)"
+
+code_reserved Quickcheck Match*)
+
+subsection \<open>The \<open>random\<close> class\<close>
+
+class random = typerep +
+  fixes random :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+
+subsection \<open>Fundamental and numeric types\<close>
+
+instantiation bool :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range 2 \<circ>\<rightarrow>
+    (\<lambda>k. Pair (if k = 0 then Code_Evaluation.valtermify False else Code_Evaluation.valtermify True))"
+
+instance ..
+
+end
+
+end
+
+instantiation itself :: (typerep) random
+begin
+
+definition
+  random_itself :: "natural \<Rightarrow> Random.seed \<Rightarrow> ('a itself \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where "random_itself _ = Pair (Code_Evaluation.valtermify TYPE('a))"
+
+instance ..
+
+end
+
+instantiation char :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random _ = Random.select (Enum.enum :: char list) \<circ>\<rightarrow> (\<lambda>c. Pair (c, \<lambda>u. Code_Evaluation.term_of c))"
+
+instance ..
+
+end
+
+end
+
+instantiation String.literal :: random
+begin
+
+definition
+  "random _ = Pair (STR '''', \<lambda>u. Code_Evaluation.term_of (STR ''''))"
+
+instance ..
+
+end
+
+instantiation nat :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_nat :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (nat \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_nat i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let n = nat_of_natural k
+     in (n, \<lambda>_. Code_Evaluation.term_of n)))"
+
+instance ..
+
+end
+
+end
+
+instantiation int :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition
+  "random i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then int (nat_of_natural (k - i)) else - (int (nat_of_natural (i - k))))
+     in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+instantiation natural :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_natural :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (natural \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_natural i = Random.range (i + 1) \<circ>\<rightarrow> (\<lambda>n. Pair (n, \<lambda>_. Code_Evaluation.term_of n))"
+
+instance ..
+
+end
+
+end
+
+instantiation integer :: random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+definition random_integer :: "natural \<Rightarrow> Random.seed
+  \<Rightarrow> (integer \<times> (unit \<Rightarrow> Code_Evaluation.term)) \<times> Random.seed"
+where
+  "random_integer i = Random.range (2 * i + 1) \<circ>\<rightarrow> (\<lambda>k. Pair (
+     let j = (if k \<ge> i then integer_of_natural (k - i) else - (integer_of_natural (i - k)))
+      in (j, \<lambda>_. Code_Evaluation.term_of j)))"
+
+instance ..
+
+end
+
+end
+
+
+subsection \<open>Complex generators\<close>
+
+text \<open>Towards \<^typ>\<open>'a \<Rightarrow> 'b\<close>\<close>
+
+axiomatization random_fun_aux :: "typerep \<Rightarrow> typerep \<Rightarrow> ('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> ('a \<Rightarrow> term)
+  \<Rightarrow> (Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> (Random.seed \<Rightarrow> Random.seed \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+
+definition random_fun_lift :: "(Random.seed \<Rightarrow> ('b \<times> (unit \<Rightarrow> term)) \<times> Random.seed)
+  \<Rightarrow> Random.seed \<Rightarrow> (('a::term_of \<Rightarrow> 'b::typerep) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+where
+  "random_fun_lift f =
+    random_fun_aux TYPEREP('a) TYPEREP('b) (=) Code_Evaluation.term_of f Random.split_seed"
+
+instantiation "fun" :: ("{equal, term_of}", random) random
+begin
+
+definition
+  random_fun :: "natural \<Rightarrow> Random.seed \<Rightarrow> (('a \<Rightarrow> 'b) \<times> (unit \<Rightarrow> term)) \<times> Random.seed"
+  where "random i = random_fun_lift (random i)"
+
+instance ..
+
+end
+
+(*text \<open>Towards type copies and datatypes\<close>
+
+context
+  includes state_combinator_syntax
+begin
+
+definition collapse :: "('a \<Rightarrow> ('a \<Rightarrow> 'b \<times> 'a) \<times> 'a) \<Rightarrow> 'a \<Rightarrow> 'b \<times> 'a"
+  where "collapse f = (f \<circ>\<rightarrow> id)"
+
+end
+
+definition beyond :: "natural \<Rightarrow> natural \<Rightarrow> natural"
+  where "beyond k l = (if l > k then l else 0)"
+
+lemma beyond_zero: "beyond k 0 = 0"
+  by (simp add: beyond_def)
+
+context
+  includes term_syntax
+begin
+
+definition [code_unfold]:
+  "valterm_emptyset = Code_Evaluation.valtermify ({} :: ('a :: typerep) set)"
+
+definition [code_unfold]:
+  "valtermify_insert x s = Code_Evaluation.valtermify insert {\<cdot>} (x :: ('a :: typerep * _)) {\<cdot>} s"
+
+end
+
+instantiation set :: (random) random
+begin
+
+context
+  includes state_combinator_syntax
+begin
+
+
+fun random_aux_set
+where
+  "random_aux_set 0 j = collapse (Random.select_weight [(1, Pair valterm_emptyset)])"
+| "random_aux_set (Code_Numeral.Suc i) j =
+    collapse (Random.select_weight
+      [(1, Pair valterm_emptyset),
+       (Code_Numeral.Suc i,
+        random j \<circ>\<rightarrow> (%x. random_aux_set i j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+
+
+lemma [code]:
+  "random_aux_set i j =
+    collapse (Random.select_weight [(1, Pair valterm_emptyset),
+      (i, random j \<circ>\<rightarrow> (%x. random_aux_set (i - 1) j \<circ>\<rightarrow> (%s. Pair (valtermify_insert x s))))])"
+proof (induct i rule: natural.induct)
+  case zero
+  show ?case by (subst select_weight_drop_zero [symmetric])
+    (simp add: random_aux_set.simps [simplified] less_natural_def)
+next
+  case (Suc i)
+  show ?case by (simp only: random_aux_set.simps(2) [of "i"] Suc_natural_minus_one)
+qed
+
+definition "random_set i = random_aux_set i i"
+
+instance ..
+
+end
+
+end
+
+lemma random_aux_rec:
+  fixes random_aux :: "natural \<Rightarrow> 'a"
+  assumes "random_aux 0 = rhs 0"
+    and "\<And>k. random_aux (Code_Numeral.Suc k) = rhs (Code_Numeral.Suc k)"
+  shows "random_aux k = rhs k"
+  using assms by (rule natural.induct)*)
+
+(*subsection \<open>Deriving random generators for datatypes\<close>
+
+ML_file \<open>Tools/Quickcheck/quickcheck_common.ML\<close>
+ML_file \<open>Tools/Quickcheck/random_generators.ML\<close>
+
+
+subsection \<open>Code setup\<close>
+
+code_printing
+  constant random_fun_aux \<rightharpoonup> (Quickcheck) "Random'_Generators.random'_fun"
+  \<comment> \<open>With enough criminal energy this can be abused to derive \<^prop>\<open>False\<close>;
+  for this reason we use a distinguished target \<open>Quickcheck\<close>
+  not spoiling the regular trusted code generation\<close>
+
+code_reserved Quickcheck Random_Generators*)
+
+hide_const (open) (*catch_match*) random (*collapse beyond*) random_fun_aux random_fun_lift
+
+hide_fact (open) (*collapse_def beyond_def*) random_fun_lift_def
+
+
+
+subsection \<open>Continuation passing style functions as plus monad\<close>
+
+type_synonym 'a cps = "('a \<Rightarrow> term list option) \<Rightarrow> term list option"
+
+definition cps_empty :: "'a cps"
+  where "cps_empty = (\<lambda>cont. None)"
+
+definition cps_single :: "'a \<Rightarrow> 'a cps"
+  where "cps_single v = (\<lambda>cont. cont v)"
+
+definition cps_bind :: "'a cps \<Rightarrow> ('a \<Rightarrow> 'b cps) \<Rightarrow> 'b cps"
+  where "cps_bind m f = (\<lambda>cont. m (\<lambda>a. (f a) cont))"
+
+definition cps_plus :: "'a cps \<Rightarrow> 'a cps \<Rightarrow> 'a cps"
+  where "cps_plus a b = (\<lambda>c. case a c of None \<Rightarrow> b c | Some x \<Rightarrow> Some x)"
+
+definition cps_if :: "bool \<Rightarrow> unit cps"
+  where "cps_if b = (if b then cps_single () else cps_empty)"
+
+definition cps_not :: "unit cps \<Rightarrow> unit cps"
+  where "cps_not n = (\<lambda>c. case n (\<lambda>u. Some []) of None \<Rightarrow> c () | Some _ \<Rightarrow> None)"
+
+type_synonym 'a pos_bound_cps =
+  "('a \<Rightarrow> (bool * term list) option) \<Rightarrow> natural \<Rightarrow> (bool * term list) option"
+
+definition pos_bound_cps_empty :: "'a pos_bound_cps"
+  where "pos_bound_cps_empty = (\<lambda>cont i. None)"
+
+definition pos_bound_cps_single :: "'a \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_single v = (\<lambda>cont i. cont v)"
+
+definition pos_bound_cps_bind :: "'a pos_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b pos_bound_cps) \<Rightarrow> 'b pos_bound_cps"
+  where "pos_bound_cps_bind m f = (\<lambda>cont i. if i = 0 then None else (m (\<lambda>a. (f a) cont i) (i - 1)))"
+
+definition pos_bound_cps_plus :: "'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps \<Rightarrow> 'a pos_bound_cps"
+  where "pos_bound_cps_plus a b = (\<lambda>c i. case a c i of None \<Rightarrow> b c i | Some x \<Rightarrow> Some x)"
+
+definition pos_bound_cps_if :: "bool \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_if b = (if b then pos_bound_cps_single () else pos_bound_cps_empty)"
+
+datatype (plugins only: code extraction) (dead 'a) unknown =
+  Unknown | Known 'a
+
+datatype (plugins only: code extraction) (dead 'a) three_valued =
+  Unknown_value | Value 'a | No_value
+
+type_synonym 'a neg_bound_cps =
+  "('a unknown \<Rightarrow> term list three_valued) \<Rightarrow> natural \<Rightarrow> term list three_valued"
+
+definition neg_bound_cps_empty :: "'a neg_bound_cps"
+  where "neg_bound_cps_empty = (\<lambda>cont i. No_value)"
+
+definition neg_bound_cps_single :: "'a \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_single v = (\<lambda>cont i. cont (Known v))"
+
+definition neg_bound_cps_bind :: "'a neg_bound_cps \<Rightarrow> ('a \<Rightarrow> 'b neg_bound_cps) \<Rightarrow> 'b neg_bound_cps"
+  where "neg_bound_cps_bind m f =
+    (\<lambda>cont i.
+      if i = 0 then cont Unknown
+      else m (\<lambda>a. case a of Unknown \<Rightarrow> cont Unknown | Known a' \<Rightarrow> f a' cont i) (i - 1))"
+
+definition neg_bound_cps_plus :: "'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps \<Rightarrow> 'a neg_bound_cps"
+  where "neg_bound_cps_plus a b =
+    (\<lambda>c i.
+      case a c i of
+        No_value \<Rightarrow> b c i
+      | Value x \<Rightarrow> Value x
+      | Unknown_value \<Rightarrow>
+          (case b c i of
+            No_value \<Rightarrow> Unknown_value
+          | Value x \<Rightarrow> Value x
+          | Unknown_value \<Rightarrow> Unknown_value))"
+
+definition neg_bound_cps_if :: "bool \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_if b = (if b then neg_bound_cps_single () else neg_bound_cps_empty)"
+
+definition neg_bound_cps_not :: "unit pos_bound_cps \<Rightarrow> unit neg_bound_cps"
+  where "neg_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Some (True, [])) i of None \<Rightarrow> c (Known ()) | Some _ \<Rightarrow> No_value)"
+
+definition pos_bound_cps_not :: "unit neg_bound_cps \<Rightarrow> unit pos_bound_cps"
+  where "pos_bound_cps_not n =
+    (\<lambda>c i. case n (\<lambda>u. Value []) i of No_value \<Rightarrow> c () | Value _ \<Rightarrow> None | Unknown_value \<Rightarrow> None)"
+
+hide_type (open) cps pos_bound_cps neg_bound_cps unknown three_valued
+
+hide_const (open) cps_empty cps_single cps_bind cps_plus cps_if cps_not
+  pos_bound_cps_empty pos_bound_cps_single pos_bound_cps_bind
+  pos_bound_cps_plus pos_bound_cps_if pos_bound_cps_not
+  neg_bound_cps_empty neg_bound_cps_single neg_bound_cps_bind
+  neg_bound_cps_plus neg_bound_cps_if neg_bound_cps_not
+  Unknown Known Unknown_value Value No_value
+
+class exhaustive = term_of +
+  fixes exhaustive :: "('a \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+class full_exhaustive = term_of +
+  fixes full_exhaustive ::
+    "('a \<times> (unit \<Rightarrow> term) \<Rightarrow> (bool \<times> term list) option) \<Rightarrow> natural \<Rightarrow> (bool \<times> term list) option"
+
+
+
+end
diff -urNx '*~' ./Rat.thy /Applications/Isabelle2022.app/src/HOL/Rat.thy
--- ./Rat.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Rat.thy	2023-06-05 09:48:57.000000000 +0900
@@ -1010,7 +1010,7 @@
   by (cases p) (simp add: quotient_of_Fract of_rat_rat)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1129,7 +1129,7 @@
   inverse_rat_inst.inverse_rat
   one_rat_inst.one_rat ord_rat_inst.less_rat
   ord_rat_inst.less_eq_rat plus_rat_inst.plus_rat times_rat_inst.times_rat
-  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat
+  uminus_rat_inst.uminus_rat zero_rat_inst.zero_rat*)
 
 
 subsection \<open>Float syntax\<close>
diff -urNx '*~' ./Real.thy /Applications/Isabelle2022.app/src/HOL/Real.thy
--- ./Real.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Real.thy	2023-06-05 09:48:57.000000000 +0900
@@ -1655,7 +1655,7 @@
       of_int_floor_le of_rat_of_int_eq real_less_eq_code)
 
 
-text \<open>Quickcheck\<close>
+(*text \<open>Quickcheck\<close>
 
 context
   includes term_syntax
@@ -1731,7 +1731,7 @@
 lemmas [nitpick_unfold] = inverse_real_inst.inverse_real one_real_inst.one_real
   ord_real_inst.less_real ord_real_inst.less_eq_real plus_real_inst.plus_real
   times_real_inst.times_real uminus_real_inst.uminus_real
-  zero_real_inst.zero_real
+  zero_real_inst.zero_real*)
 
 
 subsection \<open>Setup for SMT\<close>
diff -urNx '*~' ./String.thy /Applications/Isabelle2022.app/src/HOL/String.thy
--- ./String.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/String.thy	2023-06-05 09:48:57.000000000 +0900
@@ -40,11 +40,21 @@
 
 lemma (in comm_semiring_1) of_nat_of_char:
   \<open>of_nat (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(* this is more explicit:
+ by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_nat_add of_nat_mult of_nat_of_bool of_nat_numeral of_nat_0)
+*)
 
 lemma (in comm_ring_1) of_int_of_char:
   \<open>of_int (of_char c) = of_char c\<close>
-  by (cases c) simp
+  apply (cases c)
+  by (simp add: distrib_left mult.assoc[symmetric] split del: split_of_bool)
+(*
+  by (simp only: of_char_Char String.of_char_Char
+ horner_sum_simps Groups_List.horner_sum_simps of_int_add of_int_mult of_int_of_bool of_int_numeral of_int_0)
+*)
 
 lemma nat_of_char [simp]:
   \<open>nat (of_char c) = of_char c\<close>
@@ -698,9 +708,9 @@
 
 lemma [code]:
   \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
-    [foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
+    [foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0] + s\<close>
 proof -
-  have \<open>foldr (\<lambda>b k. of_bool b + k * 2) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
+  have \<open>foldr (\<lambda>b k. of_bool b + 2 * k) [b0, b1, b2, b3, b4, b5, b6] 0 = of_char (Char b0 b1 b2 b3 b4 b5 b6 False)\<close>
     by simp
   moreover have \<open>Literal' b0 b1 b2 b3 b4 b5 b6 s = String.literal_of_asciis
     [of_char (Char b0 b1 b2 b3 b4 b5 b6 False)] + s\<close>
diff -urNx '*~' ./Transcendental.thy /Applications/Isabelle2022.app/src/HOL/Transcendental.thy
--- ./Transcendental.thy	2022-10-25 03:37:32.000000000 +0900
+++ /Applications/Isabelle2022.app/src/HOL/Transcendental.thy	2023-06-05 09:48:57.000000000 +0900
@@ -3422,12 +3422,14 @@
     have "(-1) ^ ((n - Suc 0) div 2) * (-1) ^ ((p - Suc n) div 2) = - ((-1 :: real) ^ (p div 2))"
       if np: "odd n" "even p"
     proof -
-      have "p > 0"
-        using \<open>n \<le> p\<close> neq0_conv that(1) by blast
+      have n1: "Suc 0 \<le>  n" using odd_pos[OF that(1)] by simp
+      have opn: "odd (p - n)" using np \<open>n \<le> p\<close> by simp
+      have snp: "Suc n \<le> p" using odd_pos[OF opn] by simp
+      then have p2: "2 \<le> p" using \<open>n \<le> p\<close> that(2) by (auto elim: oddE)
       then have \<section>: "(- 1::real) ^ (p div 2 - Suc 0) = - ((- 1) ^ (p div 2))"
-        using \<open>even p\<close> by (auto simp add: dvd_def power_eq_if)
-      from \<open>n \<le> p\<close> np have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" "Suc (Suc 0) \<le> p"
-        by arith+
+        by (simp add: power_eq_if)
+      from n1 p2 snp have *: "n - Suc 0 + (p - Suc n) = p - Suc (Suc 0)" 
+        by simp
       have "(p - Suc (Suc 0)) div 2 = p div 2 - Suc 0"
         by simp
       with \<open>n \<le> p\<close> np  \<section> * show ?thesis
